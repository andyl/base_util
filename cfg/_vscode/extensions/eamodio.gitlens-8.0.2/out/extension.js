module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:s})},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=4)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("fs")},function(e,t,i){"use strict";var s,o;Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const a=s.length;for(let r=0;r<a;r++)e(t,`${i}[${r}]`,s[r],o);0===a&&(t[i]=null)}else{let a=!0;for(const r in s)a=!1,e(t,i?`${i}.${r}`:r,s[r],o);a&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const a=t[o];"object"==typeof a?s.push(...e(a,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(s||(s={})),function(e){function t(e,i,o=!0){if(void 0===e.children)return e;const a=[...s.values(e.children)];for(const e of a)t(e,i,!1);if(!o&&1===a.length){const t=a[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.makeHierarchical=function(e,i,s,o=!1){const a={name:"",relativePath:"",children:Object.create(null),descendants:[]},r=e.reduce((e,t)=>{let o=e,a="";for(const e of i(t)){a=s(a,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:a,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},a);return o?t(r,s,!0):r},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(o||(o={}));var a=i(5),r=i(6);const n=6e4,h=864e5;const c=r;c.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let a;return a="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+a:a+" ago":a}}}();const l={addSuffix:!0,locale:c};var d;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),a=s.getTime()-s.getTimezoneOffset()*n,r=o.getTime()-o.getTimezoneOffset()*n;return Math.round((a-r)/h)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(a.distanceInWordsToNow)(e,l),format:t=>Object(a.format)(e,t)}}}(d||(d={}));var m=i(2);const u=i(7),g=i(8);var p,f;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,a=m.__rest(s,["track"]);if(!0!==o)return u(e,t,a);let r=!1;const n=u(function(){return r=!1,e.apply(this,arguments)},t,i),h=function(){return r=!0,n.apply(this,arguments)};return h.pending=function(){return r},h.cancel=function(){return n.cancel.apply(n,arguments)},h.flush=function(...e){return n.flush.apply(n,arguments)},h},e.once=function(e){return g(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(p||(p={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e){let t,i=0;for(;!(t=e.next()).done;)i++;return i},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(f||(f={}));class v{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}join(e){return e.join("")}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class w{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}join(e){return e.join("/")}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(t===w._fwd||t===w._bwd){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}w._fwd="/".charCodeAt(0),w._bwd="\\".charCodeAt(0);class C{isEmpty(){return void 0===this.left&&void 0===this.mid&&void 0===this.right&&void 0===this.element}}class b{constructor(e){this._iter=e}static forPaths(){return new b(new w)}static forStrings(){return new b(new v)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new C,this._root.str=i.value()),s=this._root;;){const e=i.cmp(s.str);if(e>0)s.left||(s.left=new C,s.left.str=i.value()),s=s.left;else if(e<0)s.right||(s.right=new C,s.right.str=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new C,s.mid.str=i.value()),s=s.mid}}const o=s.element;return s.element=t,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.element:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.element=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.str);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.element||i,s=s.mid}}return s&&s.element||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.str);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new b(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,[],e)}_forEach(e,t,i){void 0!==e&&(this._forEach(e.left,t,i),t.push(e.str),e.element&&i(e.element,this._iter.join(t)),this._forEach(e.mid,t,i),t.pop(),this._forEach(e.right,t,i))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(){return void 0===this._root||this._root.isEmpty()?0:f.count(this.entries())}entries(){return this._iterator(this._root,[])}values(){return f.map(this.entries(),e=>e[0])}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}*_iterator(e,t){void 0!==e&&(yield*this._iterator(e.left,t),t.push(e.str),e.element&&(yield[e.element,this._iter.join(t)]),yield*this._iterator(e.mid,t),t.pop(),yield*this._iterator(e.right,t))}}var y,x,S=i(9);!function(e){const t=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,i=/\$\{(\w*?)(?:\W|\d)*?\}/g;function s(e,t,i=" "){const s=t-h(e);return s<=0?e:i.repeat(s)+e}function o(e,t,i=" "){const s=t-h(e);return s<=0?e:e+i.repeat(s)}e.getTokensFromTemplate=function(e){const i=[];let s=t.exec(e);for(;null!=s;){const o=s[2],a=s[3];i.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===a?"left":"right",collapseWhitespace:"?"===a}}),s=t.exec(e)}return i},e.interpolate=function(e,t){return e?void 0===t?e.replace(i,""):(e=e.replace(i,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(S.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(/\\/g,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=s,e.padLeftOrTruncate=function(e,t,i){const o=h(e);return o<t?s(e,t,i):o>t?r(e,t):e},e.padRight=o,e.padOrTruncate=function(e,t,i){const a=t<0;t=Math.abs(t);const n=h(e);return n<t?a?s(e,t,i):o(e,t,i):n>t?r(e,t):e},e.padRightOrTruncate=function(e,t,i){const s=h(e);return s<t?o(e,t,i):s>t?r(e,t):e};const a=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function r(e,t,i="…"){if(!e)return e;const s=h(e);if(s<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),a=h(e.substring(0,o));for(;a<t;)a+=h(e[o++]);return a>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(a,t):e},e.sha1=function(e,t="base64"){return Object(S.createHash)("sha1").update(e).digest(t)},e.truncate=r;const n=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g;function h(e){if(!e||0===e.length)return 0;let t=0,i=0,s=0;const o=[...e=e.replace(n,"")];for(let e=0;e<o.length;e++){const a=o[e].codePointAt(0);if(!(a<=31||a>=127&&a<=159)&&!(a>=768&&a<=879))if(a>=128512&&a<=128591||a>=127744&&a<=128511||a>=128640&&a<=128767||a>=9728&&a<=9983||a>=9984&&a<=10175||a>=65024&&a<=65039||a>=129280&&a<=129535||a>=65024&&a<=65039||a>=8400&&a<=8447){if(a>=127995&&a<=127999)continue;i++,t+=2}else 8205!==a?(a>65535&&e++,t+=c(a)?2:1):(s++,t-=2)}const a=i-s;return a>1&&(t+=a-1),t}function c(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.width=h}(y||(y={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,a,r]=i.split(".");return t(o,a,r,s)}}(x||(x={}));var $,D,k,P,F,_,R,T,E,B,N,A,U,L=i(0);!function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}($||($={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}(D||(D={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}(k||(k={})),function(e){e.Absolute="absolute",e.Relative="relative"}(P||(P={})),function(e){e.List="list",e.Tree="tree"}(F||(F={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(_||(_={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(R||(R={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(T||(T={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(E||(E={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(B||(B={})),function(e){e.Standard="standard",e.Chorded="chorded",e.None="none"}(N||(N={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(A||(A={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(U||(U={}));const O="gitlens",I="GitLens",M="GitLens",W="eamodio.gitlens",H=1e8;var j,G,V,Q,K,z;function q(e,t){return L.commands.executeCommand(j.SetContext,e,t)}function Y(e){const t=L.window.activeTextEditor;return void 0!==t&&t.document===e}function X(e){const t=e.document.uri.scheme;return t!==V.Output&&t!==V.DebugConsole}!function(e){e.CloseActiveEditor="workbench.action.closeActiveEditor",e.CloseAllEditors="workbench.action.closeAllEditors",e.CursorMove="cursorMove",e.Diff="vscode.diff",e.EditorScroll="editorScroll",e.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",e.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",e.Open="vscode.open",e.NextEditor="workbench.action.nextEditor",e.PreviewHtml="vscode.previewHtml",e.RevealLine="revealLine",e.SetContext="setContext",e.ShowReferences="editor.action.showReferences"}(j||(j={})),function(e){e.ActiveHasRemote="gitlens:activeHasRemote",e.ActiveIsBlameable="gitlens:activeIsBlameable",e.ActiveFileIsTracked="gitlens:activeIsTracked",e.ActiveIsRevision="gitlens:activeIsRevision",e.AnnotationStatus="gitlens:annotationStatus",e.CanToggleCodeLens="gitlens:canToggleCodeLens",e.Enabled="gitlens:enabled",e.ExplorersCanCompare="gitlens:explorers:canCompare",e.GitExplorer="gitlens:gitExplorer",e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.HasRemotes="gitlens:hasRemotes",e.Key="gitlens:key",e.KeyMap="gitlens:keymap",e.ResultsExplorer="gitlens:resultsExplorer",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(G||(G={})),function(e){e.DebugConsole="debug",e.File="file",e.Git="git",e.GitLensGit="gitlens-git",e.Output="output"}(V||(V={})),function(e){e.ArrowBack="↩",e.ArrowDown="↓",e.ArrowDropRight="⤷",e.ArrowLeft="←",e.ArrowLeftRight="↔",e.ArrowRight="→",e.ArrowRightHollow="⇨",e.ArrowUp="↑",e.ArrowUpRight="↗",e.Asterisk="∗",e.Check="✓",e.Dash="—",e.Dot="•",e.DoubleArrowLeft="≪",e.DoubleArrowRight="⋘",e.Ellipsis="…",e.MiddleEllipsis="⋯",e.Pensil="✎",e.Space=" ",e.SquareWithBottomShadow="❏",e.SquareWithTopShadow="❐",e.ZeroWidthSpace="​"}(Q||(Q={})),function(e){e.GitLensVersion="gitlensVersion"}(K||(K={})),function(e){e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(z||(z={}));class J{}const Z=new class extends J{equals(e,t){return e===t}},ee=new class extends J{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?Z.equals(e.document,t.document):e.id===t.id)}},te=new class extends J{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var ie;!function(e){e.Computing="computing",e.Computed="computed"}(ie||(ie={}));class se extends L.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=s,this.correlationKey=se.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=L.Disposable.from(L.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(Z.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}async clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}async reset(e){void 0===this._resetDebounced&&(this._resetDebounced=p.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=ie.Computing,e===L.window.activeTextEditor&&await q(G.AnnotationStatus,this.status),this.editor=e,this.correlationKey=se.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=ie.Computed,e===L.window.activeTextEditor&&(await q(G.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=ie.Computing,await this.onProvideAnnotation(e)?(this.status=ie.Computed,!0):(this.status=void 0,!1)}}const oe=`[${I}]`;class ae{static configure(e){e.subscriptions.push(Go.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(Go.initializingChangeEvent)}static onConfigurationChanged(e){const t=Go.initializing(e);let i=Go.name("debug").value;(t||Go.changed(e,i))&&(this.debug=Go.get(i)),i=Go.name("outputLevel").value,(t||Go.changed(e,i))&&(this.level=Go.get(i),this.level===A.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||L.window.createOutputChannel(I))}static log(e,...t){this.debug&&console.log(this.timestamp,oe,e,...t),void 0===this.output||this.level!==A.Verbose&&this.level!==A.Debug||this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static error(e,t,...i){this.debug&&console.error(this.timestamp,oe,t,e,...i),void 0!==this.output&&this.level!==A.Silent&&this.output.appendLine((this.debug?[this.timestamp,t,e,...i]:[t,e,...i]).join(" "))}static warn(e,...t){this.debug&&console.warn(this.timestamp,oe,e,...t),void 0!==this.output&&this.level!==A.Silent&&this.output.appendLine((this.debug?[this.timestamp,e,...t]:[e,...t]).join(" "))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t){this.level===A.Debug&&(void 0===this.gitOutput&&(this.gitOutput=L.window.createOutputChannel(`${I} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})`))}}ae.debug=!1,ae.level=A.Silent;class re extends L.Disposable{constructor(e,t,i,s){super(()=>this.dispose()),this._document=e,this.key=t,this.dirty=i,this._eventDelegates=s,this._onDidBlameStateChange=new L.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===Wo.git&&!await p.waitUntil(()=>void 0!==Wo.git,2e3))throw ae.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await Te.fromUri(e),this._disposed)return;const t=await Wo.git.getRepository(this._uri);return this._disposed?void 0:(this._repo=t,void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0}),t)}onRepositoryChanged(e){e.changed(Ve.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){q(G.ActiveIsRevision,this.isRevision),q(G.ActiveFileIsTracked,this.isTracked),q(G.ActiveIsBlameable,this.isBlameable),q(G.ActiveHasRemote,this.hasRemotes)}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,ae.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&Y(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=L.window.activeTextEditor;return void 0!==t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await Wo.git.isTracked(this._uri);let s=void 0;if(this._isTracked&&(s=await this._repo),this._hasRemotes=void 0!==s&&await s.hasRemote(),void 0!==t){const s=this.isBlameable;if(q(G.ActiveIsRevision,this.isRevision),q(G.ActiveFileIsTracked,this.isTracked),q(G.ActiveIsBlameable,s),q(G.ActiveHasRemote,this.hasRemotes),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}}class ne{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class he{constructor(e,t){this.commit=e,this.logCommit=t}}class ce extends L.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeBlameState=new L.EventEmitter,this._onDidChangeDirtyState=new L.EventEmitter,this._onDidTriggerDirtyIdle=new L.EventEmitter,this._documentMap=new Map,this._disposable=L.Disposable.from(Go.onDidChange(this.onConfigurationChanged,this),L.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveTextEditorChanged,0),this),L.workspace.onDidChangeTextDocument(p.debounce(this.onTextDocumentChanged,50),this),L.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),L.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(Go.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(L.window.activeTextEditor)}onConfigurationChanged(e){const t=Go.initializing(e);if(!t&&(Go.changed(e,Go.name("blame")("ignoreWhitespace").value,null)||Go.changed(e,Go.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=Go.name("advanced")("blame")("delayAfterEdit").value;(t||Go.changed(e,i))&&(this._dirtyIdleTriggerDelay=Go.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!X(e))return;if(void 0===e)return q(G.ActiveIsRevision,!1),q(G.ActiveFileIsTracked,!1),q(G.ActiveIsBlameable,!1),void q(G.ActiveHasRemote,!1);const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==V.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,s=L.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:s,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==s&&s.document===e.document&&this.fireDocumentDirtyStateChanged({editor:s,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?Y(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}async add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}async get(e){return await this._get(e)}async getOrAdd(e){return await this._get(e)||await this._add(e)}has(e){return("string"==typeof e||e instanceof L.Uri)&&(e=Te.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof Te)try{e=await L.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){if(!t.toString().includes("File not found"))throw t;e=new le(e)}else e instanceof L.Uri&&(e=await L.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof Te?e=Te.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof L.Uri)&&(e=Te.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=Te.toKey(e.uri),i=new re(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),L.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=p.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=p.debounce(async e=>{L.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class le{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=L.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}var de;function me(e){switch(e.type){case de.Branch:return"Branch";case de.Branches:return"Branches";case de.Commit:return"Commit";case de.File:return"File";case de.Repo:return"Repository";case de.Revision:return"Revision";default:return""}}!function(e){e.Branch="branch",e.Branches="branches",e.Commit="commit",e.File="file",e.Repo="repo",e.Revision="revision"}(de||(de={}));class ue{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return L.commands.executeCommand(j.Open,L.Uri.parse(e))}open(e){switch(e.type){case de.Branch:return this.openBranch(e.branch);case de.Branches:return this.openBranches();case de.Commit:return this.openCommit(e.sha);case de.File:return this.openFile(e.fileName,e.branch,void 0,e.range);case de.Repo:return this.openRepo();case de.Revision:return this.openFile(e.fileName,e.branch,e.sha,e.range)}}openRepo(){return this.openUrl(this.getUrlForRepository())}openBranches(){return this.openUrl(this.getUrlForBranches())}openBranch(e){return this.openUrl(this.getUrlForBranch(e))}openCommit(e){return this.openUrl(this.getUrlForCommit(e))}openFile(e,t,i,s){return this.openUrl(this.getUrlForFile(e,t,i,s))}}class ge extends ue{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("Bitbucket")}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}class pe extends ue{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("Bitbucket Server")}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class fe extends ue{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return y.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return y.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return y.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return y.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?y.interpolate(this.urls.fileLine,{line:s.start.line}):y.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?y.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?y.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):y.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}class ve extends ue{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitHub")}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}class we extends ue{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get name(){return this.formatName("GitLab")}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const Ce=new Map([["bitbucket.org",(e,t)=>new ge(e,t)],["github.com",(e,t)=>new ve(e,t)],["gitlab.com",(e,t)=>new we(e,t)],["visualstudio.com",(e,t)=>new class extends ue{constructor(e,t,i,s){super(e,t,i,s)}get name(){return"Visual Studio Team Services"}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class be{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void ae.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map(Ce);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case k.Bitbucket:return(t,i)=>new ge(t,i,e.protocol,e.name,!0);case k.BitbucketServer:return(t,i)=>new pe(t,i,e.protocol,e.name,!0);case k.Custom:return(t,i)=>new fe(t,i,e.urls,e.protocol,e.name);case k.GitHub:return(t,i)=>new ve(t,i,e.protocol,e.name,!0);case k.GitLab:return(t,i)=>new we(t,i,e.protocol,e.name,!0)}}}var ye=i(10),xe=i(3),Se=i(1);const $e="win32"===process.platform;function De(e){if(e.match(/[\\\/]/))return e;const t=Se.join(".",e);try{if(xe.statSync(t))return t}catch(e){}const i=process.env.PATH.split($e?";":":");for(const t of i){const i=Se.join(t,e);try{if(xe.statSync(i))return i}catch(e){}}return e}function ke(e,t,i={}){const s=Object.assign({maxBuffer:10485760},i),{stdin:o,stdinEncoding:a}=s,r=m.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object(ye.execFile)(e,t,r,(o,a,n)=>{if(!o)return n&&ae.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(a);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${r.maxBuffer} bytes`)),ae.warn(`Error(${r.cwd}): ${e} ${t.join(" ")})\n    (${o.code}) ${o.message}\n${n}`),s(o)});o&&n.stdin.end(o,a||"utf8")})}async function Pe(e){const t=await ke(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!$e)return{cmd:De(t),args:i};if(!xe.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=De(`${t}${o}`);if(xe.existsSync(s))return e(s,i)}}if(t.match(/\.ps1$/i))return{cmd:Se.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)};if(t.match(/\.(bat|cmd)$/i))return{cmd:Se.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]};if(t.match(/\.(js)$/i))return{cmd:process.execPath,args:[t].concat(i)};return{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:(i=t.trim(),i.replace(/^git version /,""))};var i}function Fe(e){return e?Pe(Se.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}async function _e(e){try{return await Pe(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await ke("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return Pe(e);try{return await ke("xcode-select",["-p"]),Pe(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):Pe(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await Fe(process.env.ProgramW6432).then(null,()=>Fe(process.env["ProgramFiles(x86)"])).then(null,()=>Fe(process.env.ProgramFiles)).then(null,()=>Pe("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}var Re=i(11);class Te extends L.Uri{constructor(e,t){if(void 0===e)return void super();if(e.scheme===V.GitLensGit){const t=JSON.parse(e.query),[i,s]=Te.ensureValidUNCPath(e.authority,Se.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!Lt.isStagedUncommitted(t.sha)&&Lt.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=Te.ensureValidUNCPath(e.authority,Se.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!Lt.isStagedUncommitted(t.sha)&&Lt.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&Lt.shortenSha(this.sha)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?L.Uri.file(this.versionedPath):L.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getFormattedPath(e=y.pad(Q.Dot,2,2),t){let i=Se.dirname(this.fsPath);return this.repoPath&&(i=Se.relative(this.repoPath,i)),void 0!==t&&(i=Se.relative(t,i)),(i=y.normalizePath(i))&&"."!==i?`${Se.basename(this.fsPath)}${e}${i}`:Se.basename(this.fsPath)}getRelativePath(e){let t=Se.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=Se.relative(e,t)),y.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new Te(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new Te(e.uri,e)}static fromFileStatus(e,t,i,s=!1){const o=L.Uri.file(Se.resolve(t,s&&e.originalFileName||e.fileName));return new Te(o,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new Te(L.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new Te(e)}static async fromUri(e){if(e instanceof Te)return e;if(!Wo.git.isTrackable(e))return new Te(e);if(e.scheme===V.GitLensGit)return new Te(e);if(e.scheme===V.Git){const t=JSON.parse(e.query),i=await Wo.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=Lt.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new Te(e,{fileName:t.path,repoPath:i,sha:s})}const t=await Wo.git.getVersionedUri(e);return void 0!==t?t:new Te(e,await Wo.git.getRepoPath(e))}static getDirectory(e,t){let i=Se.dirname(e);return void 0!==t&&(i=Se.relative(t,i)),(i=y.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=y.pad(Q.Dot,2,2),i){let s;if(e instanceof L.Uri){if(e instanceof Te)return e.getFormattedPath(t,i);s=e.fsPath}else s=e;const o=Te.getDirectory(s,i);return o?`${Se.basename(s)}${t}${o}`:Se.basename(s)}static getRelativePath(e,t,i){let s;if(e instanceof L.Uri){if(e instanceof Te)return e.getRelativePath(t);s=e.fsPath}else s=e;let o=Se.relative(i||"",s);return void 0!==t&&(o=Se.relative(t,o)),y.normalizePath(o)}static toKey(e){return y.normalizePath("string"==typeof e?e:e.fsPath).toLowerCase()}static toRevisionUri(e,t,i){let s,o,a;"string"==typeof e?(s="string"==typeof t?t:Se.resolve(i,t.fileName),o=e,a=Lt.shortenSha(o)):(s=e.fsPath,i=e.repoPath,o=e.sha,a=e.shortSha);const r={fileName:y.normalizePath(Se.relative(i,s)),repoPath:i,sha:o},n=Se.parse(s);return L.Uri.parse(`${V.GitLensGit}:${Se.join(n.dir,n.name)}:${a}${n.ext}?${JSON.stringify(r)}`)}}const Ee=new Map;var Be;!function(e){e.Blame="blame",e.Branch="branch",e.File="file",e.Stash="stash",e.StashFile="stash-file"}(Be||(Be={}));const Ne={dateFormat:void 0,dateStyle:void 0,reset:()=>{Ne.dateStyle=Go.get(Go.name("defaultDateStyle").value),Ne.dateFormat=Go.get(Go.name("defaultDateFormat").value)}};class Ae{constructor(e,t,i,s,o,a,r,n,h,c,l){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=a,this.message=r,this.type=e,this._fileName=n||"",this.originalFileName=h,this._previousSha=c,this.previousFileName=l}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return Ne.dateStyle===P.Absolute?this.formatDate(Ne.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=Ft.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===Be.Blame||this.type===Be.File||this.type===Be.StashFile}get isStash(){return this.type===Be.Stash||this.type===Be.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=Ft.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=Ft.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return Ft.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&Ft.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?L.Uri.file(Se.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return L.Uri.file(Se.resolve(this.repoPath,this.fileName))}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=d.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=d.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=y.pad(Q.Dot,2,2)){return Te.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let s=Ee.get(i);if(void 0!==s)return s;const o=(s=L.Uri.parse(`https://www.gravatar.com/avatar/${this.email?y.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return s.toString=function(e){return o.call(s,!0)},Ee.set(i,s),s}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await Wo.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return Te.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class Ue extends Ae{constructor(e,t,i,s,o,a,r,n,h,c,l){super(Be.Blame,e,t,i,s,o,a,r,n,h,c),this.lines=l}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new Ue(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}class Le{constructor(e,t,i=!1,s,o=0,a=0){this.repoPath=e,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.current=i,this.name=t,this.tracking=""===s||null==s?void 0:s,this.state={ahead:o,behind:a}}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Le.getRemote(this.name):void 0!==this.tracking?Le.getRemote(this.tracking):void 0}isValid(){return Le.isValid(this.name)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static isValid(e){return null===e.match(/\s/)}}const Oe=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,Ie=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,Me=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class We{static parse(e,t=!1){if(!e)return;const i=[];let s,o,a,r=null;do{if(null==(r=Me.exec(`${e}\n@@`)))break;s=(" "+r[5]).substr(1),o=parseInt(r[3],10),a=parseInt(r[1],10),i.push(new He(s,{start:o,end:o+parseInt(r[4],10)},{start:a,end:a+parseInt(r[2],10)}))}while(null!=r);if(!i.length)return;return{diff:t?e:void 0,chunks:i}}static parseChunk(e){const t=f.skip(y.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const a=[];let r=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))r={line:n.line,state:n.state,previous:[s[e]]},a.push(r);else{if(void 0===r)continue;if(void 0===r.previous){r.previous=[s[e]];continue}r.previous.push(s[e])}return a}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Oe.exec(e)))break;i.push(vt.parseStatusFile(t,s[1],s[2],s[3]))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=Ie.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class He{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=We.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class je extends Ae{constructor(e,t,i,s,o,a,r,n,h,c,l,d,m,u){super(e,t,i,s,o,a,r,n,l,d,m),this.fileStatuses=h,this.status=c,this.parentShas=u}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&Ft.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?L.Uri.file(Se.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t;if("string"==typeof e){const i=y.normalizePath(Se.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;const i=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?Be.StashFile:Be.File,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:i,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new je(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var Ge,Ve,Qe;!function(e){e.Fetch="fetch",e.Push="push"}(Ge||(Ge={}));class Ke{constructor(e,t,i,s,o,a){this.repoPath=e,this.name=t,this.domain=i,this.path=s,this.provider=o,this.types=a}}!function(e){e.Config="config",e.Remotes="remotes",e.Repository="repository",e.Stashes="stashes",e.Tags="tags"}(Ve||(Ve={}));class ze{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}!function(e){e.StatusNode="statusNode"}(Qe||(Qe={}));class qe extends L.Disposable{constructor(e,t,i,s,o){super(()=>this.dispose()),this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=s,this._onDidChange=new L.EventEmitter,this._onDidChangeFileSystem=new L.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this.formattedName=i?e.name:`${e.name} (${Se.relative(e.uri.fsPath,t)})`,this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=o;const a=L.workspace.createFileSystemWatcher(new L.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=L.Disposable.from(a,a.onDidChange(this.onRepositoryChanged,this),a.onDidCreate(this.onRepositoryChanged,this),a.onDidDelete(this.onRepositoryChanged,this),Go.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(Go.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=Go.initializing(e),i=Go.name("remotes").value;(t||Go.changed(e,i,this.folder.uri))&&(this._providerMap=be.createMap(Go.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(Ve.Remotes)))}onFileSystemChanged(e){/\.git/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(Ve.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(Ve.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(Ve.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(Ve.Config,Ve.Remotes);this.onAnyRepositoryChanged(this),this.fireChange(Ve.Repository)}}}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=p.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new ze(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=p.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}containsUri(e){return e instanceof Te&&(e=void 0!==e.repoPath?L.Uri.file(e.repoPath):e.fileUri()),this.folder===L.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=Wo.git.getBranch(this.path)),this._branch}getBranches(){return Wo.git.getBranches(this.path)}getChangedFilesCount(e){return Wo.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=Go.get(Go.name("remotes").value,this.folder.uri);this._providerMap=be.createMap(e)}this._remotes=Wo.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return Wo.git.getStashList(this.path)}getStatus(){return Wo.git.getStatusForRepo(this.path)}getTags(){return Wo.git.getTags(this.path)}async hasRemote(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=L.workspace.createFileSystemWatcher(new L.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=L.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}}class Ye extends je{constructor(e,t,i,s,o,a,r,n,h,c,l,d){super(e,i,s,"You",void 0,o,a,r,n,h,c,void 0===l?`${s}^`:l,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new Ye(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class Xe{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return L.Uri.file(Se.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return Xe.getFormattedDirectory(this,e)}getFormattedPath(e=y.pad(Q.Dot,2,2)){return Xe.getFormattedPath(this,e)}getOcticon(){return Ze(this.status)}with(e){return new Xe(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=Te.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${y.pad(Q.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=y.pad(Q.Dot,2,2),i){return Te.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return Te.getRelativePath(e.fileName,t)}}const Je={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function Ze(e,t=Q.Space.repeat(4)){return Je[e]||t}const et={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function tt(e){return et[e]||et.X}class it{constructor(e,t){this.repoPath=e,this.name=t}}class st{static parse(e,t,i){if(!e)return;const s=new Map,o=new Map,a=[];let r,n,h=t&&i,c=void 0,l=!0;for(r of y.lines(e))if(!((n=r.split(" ")).length<2))if(void 0!==c)switch(n[0]){case"author":c.author=Ft.isUncommitted(c.sha)?"You":n.slice(1).join(" ").trim();break;case"author-mail":c.authorEmail=n.slice(1).join(" ").trim();const e=c.authorEmail.indexOf("<");if(e>=0){const t=c.authorEmail.indexOf(">",e);c.authorEmail=t>e?c.authorEmail.substring(e+1,t):c.authorEmail.substring(e+1)}break;case"author-time":c.authorDate=n[1];break;case"author-tz":c.authorTimeZone=n[1];break;case"summary":c.summary=n.slice(1).join(" ").trim();break;case"previous":c.previousSha=n[1],c.previousFileName=n.slice(2).join(" ");break;case"filename":c.fileName=n.slice(1).join(" "),l&&void 0===t&&(t=y.normalizePath(i.replace(i.startsWith("/")?`/${c.fileName}`:c.fileName,"")),h=y.normalizePath(Se.relative(t,i))),l=!1,st.parseEntry(c,t,h,o,s,a),c=void 0}else c={sha:n[0],originalLine:parseInt(n[1],10)-1,line:parseInt(n[2],10)-1,lineCount:parseInt(n[3],10)};return o.forEach(e=>{if(void 0===e.author)return;const t=s.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...s.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:o,lines:a}}static parseEntry(e,t,i,s,o,a){let r=s.get(e.sha);if(void 0===r){if(void 0!==e.author){let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}r=new Ue(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,r)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};r.previousSha&&(i.previousSha=r.previousSha),r.lines.push(i),a[i.line]=i}}}const ot=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,at=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class rt{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=ot.exec(e)))break;const[o,a]=this.parseState(s[5]);i.push(new Le(t,s[2],"*"===s[1],s[4],o,a))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=at.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const nt=/diff --git a\/(.*) b\/(.*)/,ht={};class ct{static parse(e,t,i,s,a,r,n,h){if(!e)return;let c,l,d=void 0,m=ht,u=void 0,g=0,p=!0;const f=y.lines(e+"</f>");let v=f.next();if(v.done)return;void 0!==i&&(i=y.normalizePath(i));const w=new Map,C=new Map;for(;!((v=f.next()).done||(u=v.value,n&&r&&g>=r));)switch(l=u.charCodeAt(1)){case 114:m={ref:u.substring(4)};break;case 97:m.author=Ft.isUncommitted(m.ref)?"You":u.substring(4);break;case 101:m.email=u.substring(4);break;case 100:m.date=u.substring(4);break;case 112:m.parentShas=u.substring(4).split(" ");break;case 115:for(;!(v=f.next()).done&&"</s>"!==(u=v.value);)void 0===m.summary?m.summary=u:m.summary+=`\n${u}`;void 0!==m.summary&&(m.summary=m.summary.slice(0,-1));break;case 102:if((v=f.next()).done||"</f>"===v.value)break;for(;!(v=f.next()).done&&"</f>"!==(u=v.value);)if(!u.startsWith("warning:"))if(t===Be.Branch){const e={status:u[0],fileName:u.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===m.fileStatuses&&(m.fileStatuses=[]),m.fileStatuses.push(e))}else{if(u.startsWith("diff")){const e=nt.exec(u);if(null!=e){m.fileName=e[1];const t=e[2];m.fileName!==t&&(m.originalFileName=t),m.status=m.fileName!==m.originalFileName?"R":"M"}for(;!(v=f.next()).done&&"</f>"!==v.value;);break}m.status=u[0],m.fileName=u.substring(1),this.parseFileName(m)}void 0!==m.fileStatuses&&(m.fileName=o.filterMap(m.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),p&&void 0===i&&t===Be.File&&void 0!==s?(i=y.normalizePath(s.replace(s.startsWith("/")?`/${m.fileName}`:m.fileName,"")),c=y.normalizePath(Se.relative(i,s))):c=m.fileName,p=!1;const e=C.get(m.ref);void 0===e&&g++,d=ct.parseEntry(m,e,t,i,c,C,w,d)}return{repoPath:i,authors:w,commits:C,sha:a,count:g,maxCount:r,range:h,truncated:!!(r&&g>=r&&1!==r)}}static parseEntry(e,t,i,s,o,a,r,n){if(void 0===t){if(void 0!==e.author){let t=r.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},r.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===Be.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new je(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),a.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===Be.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const lt=/^(.*)\t(.*)\s\((.*)\)$/gm,dt=/^(?:git:\/\/(.*?)\/|https:\/\/(.*?)\/|http:\/\/(.*?)\/|git@(.*):|ssh:\/\/(?:.*@)?(.*?)(?::.*?)?\/)(.*)$/;class mt{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let a=null;do{if(null==(a=lt.exec(e)))break;const r=a[2],[n,h]=this.parseGitUrl(r),c=`${n}/${h}`;let l=o[c];void 0===l?(l=new Ke(t,a[1],n,h,i(n,h),[{url:r,type:a[3]}]),s.push(l),o[c]=l):l.types.push({url:r,type:a[3]})}while(null!=a);return s.length?s:[]}static parseGitUrl(e){const t=dt.exec(e);return null==t?["",""]:[t[1]||t[2]||t[3]||t[4]||t[5],t[6].replace(/\.git\/?$/,"")]}}const ut={};class gt{static parse(e,t){if(!e)return;const i=y.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=y.normalizePath(t));const a=new Map;let r,n=ut,h=void 0;for(;!(s=i.next()).done;)switch(r=(h=s.value).charCodeAt(1)){case 114:n={ref:h.substring(4)};break;case 100:n.date=h.substring(4);break;case 108:n.stashName=h.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(h=s.value);)void 0===n.summary?n.summary=h:n.summary+=`\n${h}`;void 0!==n.summary&&(n.summary=n.summary.slice(0,-1));break;case 102:if((s=i.next()).done||"</f>"===s.value)break;for(;!(s=i.next()).done&&"</f>"!==(h=s.value);){if(h.startsWith("warning:"))continue;const e={status:h[0],fileName:h.substring(1),originalFileName:void 0};ct.parseFileName(e),e.fileName&&(void 0===n.fileStatuses&&(n.fileStatuses=[]),n.fileStatuses.push(e))}void 0!==n.fileStatuses&&(n.fileNames=o.filterMap(n.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "));let e=a.get(n.ref);e=gt.parseEntry(n,e,t,a)}return{repoPath:t,commits:a}}static parseEntry(e,t,i,s){return void 0===t&&(t=new Ye(Be.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const pt=/(?:ahead ([0-9]+))/,ft=/(?:behind ([0-9]+))/;class vt{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let a,r=-1;for(;++r<e.length;){const n=e[r];if(n.startsWith("##")){const e=n.split(" ");if([i,a]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=pt.exec(t);o.ahead=null==i?0:+i[1]||0;const s=ft.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,a]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,a.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return{branch:i||"",repoPath:y.normalizePath(t),sha:"",state:o,files:s,upstream:a}}static parseV2(e,t){let i;const s=[];let o;const a={ahead:0,behind:0};let r,n=-1;for(;++n<e.length;){const h=e[n];if(h.startsWith("#")){const e=h.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":r=e[2];break;case"branch.ab":a.ahead=+e[2].substring(1),a.behind=+e[3].substring(1)}}else{const e=h.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return{branch:i||"",repoPath:y.normalizePath(t),sha:o||"",state:a,files:s,upstream:r}}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let a=void 0;return t.length>1&&(""!==(a="."!==t[1]?t[1].trim():void 0)&&null!==a||(a=void 0)),new Xe(e,o,a,i,s)}}class wt{static parse(e,t){if(!e)return;const i=o.filterMap(e.split("\n"),e=>e?new it(t,e):void 0);return i.length?i:void 0}}let Ct;const bt=["blame","--root","--incremental"],yt=["log","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],xt=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],St={notARepository:/Not a git repository/,outsideRepository:/is outside repository/,noPath:/no such path/,noCommits:/does not have any commits/,notFound:/Path \'.*?\' does not exist in/,foundButNotInRevision:/Path \'.*?\' exists on disk, but not in/,headNotABranch:/HEAD does not point to a branch/,noUpstream:/no upstream configured for branch \'(.*?)\'/,unknownRevision:/ambiguous argument \'.*?\': unknown revision or path not in the working tree/};async function $t(e,...t){try{return await kt(e,...t)}catch(i){return Pt(i,e,...t)}}const Dt=new Map;async function kt(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=m.__rest(e,["correlationKey"]),a=e.encoding||"utf8",r=Object.assign({},o,{encoding:"utf8"===a?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE"})}),n=`git ${t.join(" ")}`,h=`(${r.cwd}${void 0!==s?s:""}): ${n}`;let c,l=Dt.get(h);void 0===l?(ae.log(`Running${h}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),l=ke(Ct.path,t,r),Dt.set(h,l)):ae.log(`Awaiting${h}`);try{c=await l}finally{Dt.delete(h);const e=process.hrtime(i),t=`in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;ae.log(`Completed${h} ${t}`),ae.logGitCommand(`${n} ${t}`,r.cwd)}return"utf8"===a||"binary"===a?c:Re.decode(Buffer.from(c,"binary"),a)}function Pt(e,t,...i){const o=e&&e.toString();if(o)for(const e of s.values(St))if(e.test(o))return ae.warn("git",...i,`  cwd='${t.cwd}'`,`\n  ${o.replace(/\r?\n|\r/g," ")}`),"";throw ae.error(e,"git",...i,`  cwd='${t.cwd}'`,o&&`\n  ${o.replace(/\r?\n|\r/g," ")}`),e}class Ft{static gitInfo(){return Ct}static getEncoding(e){return void 0!==e&&Re.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();Ct=await _e(e);const i=process.hrtime(t);return ae.log(`Git found: ${Ct.version} @ ${"git"===Ct.path?"PATH":Ct.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),Ct}static async getVersionedFile(e,t,s){const o=await Ft.show(e,t,s,{encoding:"binary"});if(void 0===o)return;Ft.isStagedUncommitted(s)&&(s="");const a=y.truncate(y.sanitizeForFileSystem(Ft.isSha(s)?Ft.shortenSha(s):s),50,""),r=Se.extname(t),n=await new Promise(function(e){e()}).then(i.bind(null,12));return new Promise((i,h)=>{n.file({prefix:`${Se.basename(t,r)}-${a}__`,postfix:r},(a,r,n,c)=>{a?h(a):(ae.log(`getVersionedFile[${r}]('${e}', '${t}', ${s})`),xe.appendFile(r,o,{encoding:"binary"},e=>{e?h(e):i(r)}))})})}static isResolveRequired(e){return Ft.isSha(e)&&!Ft.shaStrictRegex.test(e)}static isSha(e){return Ft.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&Ft.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&Ft.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({stagedUncommitted:"index",uncommitted:"",working:""},t),""===e)return t.working;if(Ft.isStagedUncommitted(e))return t.stagedUncommitted;if(Ft.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=y.normalizePath(e);const i=((t=y.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=y.normalizePath(i?Se.dirname(e):t),e=y.normalizePath(i?Se.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=Ct.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,a]=Ft.splitPath(t,e),r=[...bt];let n;return s.ignoreWhitespace&&r.push("-w"),null!=s.startLine&&null!=s.endLine&&r.push(`-L ${s.startLine},${s.endLine}`),i&&(Ft.isStagedUncommitted(i)?(r.push("--contents","-"),n=await Ft.show(e,t,":")):r.push(i)),$t({cwd:a,stdin:n},...r,"--",o)}static async blame_contents(e,t,i,s={}){const[o,a]=Ft.splitPath(t,e),r=[...bt];return s.ignoreWhitespace&&r.push("-w"),null!=s.startLine&&null!=s.endLine&&r.push(`-L ${s.startLine},${s.endLine}`),r.push("--contents","-"),$t({cwd:a,stdin:i,correlationKey:s.correlationKey},...r,"--",o)}static branch(e,t={all:!1}){const i=["branch","-vv"];return t.all&&i.push("-a"),$t({cwd:e},...i)}static checkout(e,t,i){const[s,o]=Ft.splitPath(t,e);return $t({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await kt({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const a=["diff","--diff-filter=M","-M","--no-ext-diff"];return i&&a.push(Ft.isStagedUncommitted(i)?"--staged":i),s&&a.push(Ft.isStagedUncommitted(s)?"--staged":s),$t({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...a,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),$t({cwd:e},...o)}static diff_shortstat(e,t){const i=["diff","--shortstat","--no-ext-diff"];return t&&i.push(t),$t({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),$t({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),$t({cwd:e},...o)}static log(e,t){const i=[...yt,"--full-history","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!Ft.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),$t({cwd:e},...i)}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=Ft.splitPath(t,e),a=[...yt];return i.maxCount&&!i.reverse&&a.push(`-n${i.maxCount}`),i.renames&&a.push("--follow","-m","--first-parent"),i.ref&&!Ft.isStagedUncommitted(i.ref)&&(i.reverse?a.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):a.push(i.ref)),null!=i.startLine&&null!=i.endLine&&a.push(`-L ${i.startLine},${i.endLine}:${s}`),a.push("--",s),$t({cwd:o},...a)}static async log_recent(e,t){try{return(await kt({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await kt({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[...yt,"-m","-i"];return i.maxCount&&s.push(`-n${i.maxCount}`),$t({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!Ft.isStagedUncommitted(t.ref)&&i.push(t.ref),$t({cwd:e},...i)}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!Ft.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await kt({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),$t({cwd:e},...o,t,i)}static remote(e){return $t({cwd:e},"remote","-v")}static remote_url(e,t){return $t({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await kt({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return await kt(i,...t)}catch(e){const s=e&&e.toString();if(St.headNotABranch.test(s))return;const o=St.noUpstream.exec(s);if(null!==o)return o[1];if(St.unknownRevision.test(s))try{const e=["symbolic-ref","-q","--short","HEAD"];return await kt(i,...e)}catch(e){return}return Pt(e,i,...t)}}static async revparse_toplevel(e){try{return(await kt({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,a]=Ft.splitPath(t,e);if(Ft.isStagedUncommitted(i)&&(i=":"),Ft.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const r={cwd:a,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await kt(r,"show",n)}catch(e){const t=e&&e.toString();if(St.notFound.test(t)||St.foundButNotInRevision.test(t))return;return Pt(e,r,n)}}static stash_apply(e,t,i){if(t)return $t({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return $t({cwd:e},"stash","drop",t)}static stash_list(e){return $t({cwd:e},...xt)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),$t({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),$t({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return $t({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=Ft.splitPath(t,e),a=i>=2?`--porcelain=v${i}`:"--porcelain";return $t({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"status",a,s)}static tag(e){return $t({cwd:e},...["tag","-l"])}}Ft.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,Ft.shaStrictRegex=/^[0-9a-f]{40}$/,Ft.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,Ft.stagedUncommittedSha="0000000000000000000000000000000000000000:",Ft.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,Ft.uncommittedSha="0000000000000000000000000000000000000000";class _t{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;const s=y.width(e);if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=this.collapsableWhitespace-s;return this.collapsableWhitespace=0,i<=0?e:void 0===t.truncateTo?e:y.padLeft(e,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?y.padLeft(e,i):(t.collapseWhitespace&&(i-=o),y.padRight(e,i))):o<0?y.truncate(e,i):e}static fromTemplateCore(e,t,i,s){if(e instanceof _t)return y.interpolate(t,e);let o=void 0;if(null==s||"string"==typeof s){o={dateFormat:s,tokenOptions:y.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}}else o=s;return void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),y.interpolate(t,this._formatter)}}_t._formatter=void 0;class Rt extends _t{get ago(){const e=this._item.fromNow();return this._padOrTruncate(e,this._options.tokenOptions.ago)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._item.fromNow()}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){const e=this._item.formatDate(this._options.dateFormat);return this._padOrTruncate(e,this._options.tokenOptions.date)}get id(){return this._item.isUncommitted&&!this._item.isStagedUncommitted?"00000000":this._item.shortSha}get message(){let e=this._item.isUncommitted?"Uncommitted change":this._item.message;if(this._options.truncateMessageAtNewLine){const t=e.indexOf("\n");-1!==t&&(e=`${e.substring(0,t)}${Q.Space}${Q.Ellipsis}`)}return this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class Tt extends _t{get directory(){const e=Xe.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=Se.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=Xe.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=Xe.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${Q.Pensil} ${Q.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}var Et,Bt,Nt,At,Ut;!function(e){e.Author="author",e.ChangedOccurrences="changed-occurrences",e.Changes="changes",e.Files="files",e.Message="message",e.Sha="sha"}(Et||(Et={}));class Lt extends L.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeRepositories=new L.EventEmitter,this._suspended=!1,this._repositoryTree=b.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=L.Disposable.from(L.window.onDidChangeWindowState(this.onWindowStateChanged,this),L.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),Go.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(Go.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return Wo.config.advanced.caching.enabled}onAnyRepositoryChanged(e){this._trackedCache.clear()}onConfigurationChanged(e){(Go.initializing(e)||Go.changed(e,Go.name("defaultDateStyle").value)||Go.changed(e,Go.name("defaultDateFormat").value))&&Ne.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:L.workspace.workspaceFolders||[],removed:[]},ae.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==V.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==V.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...f.map(i.entries(),([t,i])=>[t,Se.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=Go.get(Go.name("advanced")("repositorySearchDepth").value,t);ae.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const o=process.hrtime(),a=[],r=this.onAnyRepositoryChanged.bind(this),n=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==n&&(ae.log(`Repository found in '${n}'`),a.push(new qe(e,n,!0,r,this._suspended))),i<=0){const e=process.hrtime(o);return ae.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),a}let h=Object.assign({},L.workspace.getConfiguration("files",t).get("exclude",{}),L.workspace.getConfiguration("search",t).get("exclude",{}));h=[...f.filterMap(s.entries(h),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));const c=await this.repositorySearchCore(t.fsPath,i,h);for(let t of c){if(t=Se.dirname(t),y.normalizePath(t)===n)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(ae.log(`Repository found in '${i}'`),a.push(new qe(e,i,!1,r,this._suspended)))}const l=process.hrtime(o);return ae.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*l[0]+Math.floor(l[1]/1e6)} ms`),a}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,a)=>{xe.readdir(e,async(r,n)=>{if(null!=r)return void a(r);if(0===n.length)return void o(s);const h=[],c=n.map(t=>{const o=Se.resolve(e,t);return new Promise((e,a)=>{xe.stat(o,(a,r)=>{".git"===t?s.push(o):null==a&&!0!==i[t]&&null!=r&&r.isDirectory()&&h.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of h)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await q(G.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await q(G.HasRemotes,i),!t){const e=L.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=L.Disposable.from(e,e.onDidCreate(async e=>{const i=L.workspace.getWorkspaceFolder(e);if(void 0===i)return;const s=await this.repositorySearch(i);if(0!==s.length){t.dispose();for(const e of s)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,ae.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),Ft.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t){return await new Promise((i,s)=>xe.exists(Se.resolve(e,t),i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&f.first(s.commits.values());if(o)return o;const a=await this.findNextFileName(e,t,i);return a&&(o=(s=await this.getLogForFile(e,a,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&f.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=Ft.splitPath(t,e),await this.fileExists(e,t)?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=f.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=Ft.splitPath(s,t)):s=y.normalizePath(Se.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){if(void 0===e){const e=this.getHighlanderRepoPath();if(void 0!==e)return e}if(void 0===(e=e||L.window.activeTextEditor))return;const t=await Wo.tracker.getOrAdd(e.document.uri);return void 0!==t?t.uri.repoPath:void 0}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await Wo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return ae.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}ae.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new ne(i.key))}else ae.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(ae.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return ae.log(`Skipping blame; '${e.fsPath}' is not tracked`),Lt.emptyPromise;const[s,o]=Ft.splitPath(e.fsPath,e.repoPath,!1);try{const a=await Ft.blame(o,s,e.sha,{ignoreWhitespace:Wo.config.blame.ignoreWhitespace});return st.parse(a,o,s)}catch(e){if(void 0!==t.state){const s=e&&e.toString();return ae.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:Lt.emptyPromise,errorMessage:s}),t.setBlameFailure(),Lt.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${y.sha1(t)}`,s=await Wo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return ae.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}ae.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new ne(s.key))}else ae.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(ae.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return ae.log(`Skipping blame; '${e.fsPath}' is not tracked`),Lt.emptyPromise;const[o,a]=Ft.splitPath(e.fsPath,e.repoPath,!1);try{const e=await Ft.blame_contents(a,o,t,{correlationKey:`:${s}`,ignoreWhitespace:Wo.config.blame.ignoreWhitespace});return st.parse(e,a,o)}catch(e){if(void 0!==i.state){const t=e&&e.toString();return ae.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:Lt.emptyPromise,errorMessage:t}),i.setBlameFailure(),Lt.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(ae.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await Ft.blame(e.repoPath,o,e.sha,{ignoreWhitespace:Wo.config.blame.ignoreWhitespace,startLine:s,endLine:s}),a=st.parse(i,e.repoPath,o);if(void 0===a)return;return{author:f.first(a.authors.values()),commit:f.first(a.commits.values()),line:a.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(ae.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const a=s.commits.get(o.sha);if(void 0===a)return;return{author:Object.assign({},s.authors.get(a.author),{lineCount:a.lines.length}),commit:a,line:o}}const o=t+1,a=e.fsPath;try{const s=await Ft.blame_contents(e.repoPath,a,i,{ignoreWhitespace:Wo.config.blame.ignoreWhitespace,startLine:o,endLine:o}),r=st.parse(s,e.repoPath,a);if(void 0===r)return;return{author:f.first(r.authors.values()),commit:f.first(r.commits.values()),line:r.lines[t]}}catch(e){return}}async getBlameForRange(e,t){ae.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(ae.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),a=new Map,r=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});r.set(t.sha,e);let s=a.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},a.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...a.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:r,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;ae.log(`getBranch('${e}')`);const t=await Ft.revparse_currentBranch(e);if(void 0===t)return;const i=t.split("\n");return new Le(e,i[0],!0,i[1])}async getBranches(e){if(void 0===e)return[];ae.log(`getBranches('${e}')`);const t=await Ft.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return rt.parse(t,e)||[]}async getChangedFilesCount(e,t){ae.log(`getChangedFilesCount('${e}', '${t}')`);const i=await Ft.diff_shortstat(e,t);return We.parseShortStat(i)}async getConfig(e,t){return ae.log(`getConfig('${e}', '${t}')`),await Ft.config_get(e,t)}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await Wo.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const a=o.state.get(s);if(void 0!==a)return ae.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),a.item}ae.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new ne(o.key))}else ae.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const a=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:Lt.getEncoding(e)},o,s);return void 0!==o.state&&(ae.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:a})),a}async getDiffForFileCore(e,t,i,s,o,a,r){const[n,h]=Ft.splitPath(t,e,!1);try{const e=await Ft.diff(h,n,i,s,o);return We.parse(e)}catch(e){if(void 0!==a.state){const t=e&&e.toString();return ae.log(`Replace diff cache with empty promise for '${a.state.key}:${r}'`),a.state.set(r,{item:Lt.emptyPromise,errorMessage:t}),Lt.emptyPromise}return}}async getDiffForLine(e,t,i,s){ae.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const a=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===a)return;return a.lines[t-a.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){ae.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await Ft.diff_nameStatus(e,t,i,s);return We.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await Ft.log_recent(e,t)}async getLogCommit(e,t){ae.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){ae.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||Ft.isResolveRequired(i.ref)?o||f.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),ae.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?Wo.config.advanced.maxListItems||0:t.maxCount;try{const s=await Ft.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=ct.parse(s,Be.Branch,e,void 0,t.ref,i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){ae.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?Wo.config.advanced.maxListItems||0:s.maxCount,a=void 0;switch(i){case Et.Author:a=[`--author=${t}`];break;case Et.ChangedOccurrences:a=[`-S${t}`,"--pickaxe-regex"];break;case Et.Changes:a=[`-G${t}`];break;case Et.Files:a=["--",`${t}`];break;case Et.Message:a=[`--grep=${t}`];break;case Et.Sha:a=[t],o=1}try{const r=await Ft.log_search(e,a,{maxCount:o}),n=ct.parse(r,Be.Branch,e,void 0,void 0,o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===y.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=Wo.config.advanced.fileHistoryFollowsRenames);let s="log";void 0!==i.ref&&(s+=`:${i.ref}`),void 0!==i.maxCount&&(s+=`:n${i.maxCount}`),i.renames&&(s+=":follow");const o=await Wo.tracker.getOrAdd(new Te(L.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range&&!i.reverse){if(void 0!==o.state){const a=o.state.get(s);if(void 0!==a)return ae.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),a.item;if("log"!==s){const a=o.state.get("log");if(void 0!==a){if(void 0===i.ref)return ae.log(`getLogForFile[Cached(~${s})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),a.item;ae.log(`getLogForFile[? Cache(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const o=await a.item;if(void 0!==o&&o.commits.has(i.ref))return ae.log(`getLogForFile[Cached(${s})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),a.item}}}ae.log(`getLogForFile[Not Cached(${s})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===o.state&&(o.state=new ne(o.key))}else ae.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const a=this.getLogForFileCore(e,t,i,o,s);return void 0===o.state||void 0!==i.range||i.reverse||(ae.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:a})),a}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return ae.log(`Skipping log; '${t}' is not tracked`),Lt.emptyPromise;const[a,r]=Ft.splitPath(t,e,!1);try{const{range:n}=i,h=m.__rest(i,["range"]),c=null==i.maxCount?Wo.config.advanced.maxListItems||0:i.maxCount,l=await Ft.log_file(r,a,Object.assign({},h,{maxCount:c,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),d=ct.parse(l,Be.File,r,a,h.ref,c,h.reverse,n);if(void 0!==d){const s=Object.assign({},i);d.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return d}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return ae.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:Lt.emptyPromise,errorMessage:t}),Lt.emptyPromise}return}}async hasRemote(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemote()}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async getMergeBase(e,t,i,s={}){try{const o=await Ft.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void ae.error(e,"GitService.getMergeBase")}}async getRemotes(e){if(void 0===e)return[];ae.log(`getRemotes('${e}')`);const t=await this.getRepository(e);return void 0!==t?t.getRemotes():this.getRemotesCore(e)}async getRemotesCore(e,t){if(void 0===e)return[];ae.log(`getRemotesCore('${e}')`),t=t||be.createMap(Go.get(Go.name("remotes").value,null));try{const i=await Ft.remote(e);return mt.parse(i,e,be.factory(t))}catch(e){return ae.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(void 0===e)return await this.getActiveRepoPath();if(e instanceof Te)return e.repoPath;const i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;if("string"!=typeof e){const t=await Wo.git.getVersionedUri(e);if(void 0!==t)return t.repoPath}const s=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===s)return;if(void 0!==this._repositoryTree.get(s))return s;const o=this._repositoryTree.findSubstr(s),a=void 0===o?L.workspace.getWorkspaceFolder(L.Uri.file(s)):o.folder;if(void 0!==a){const e=new qe(a,s,!1,this.onAnyRepositoryChanged.bind(this),this._suspended);this._repositoryTree.set(s,e),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}return s}async getRepoPathCore(e,t){try{return await Ft.revparse_toplevel(t?e:Se.dirname(e))}catch(e){return void ae.error(e,"GitService.getRepoPathCore")}}async getRepositories(){return(await this.getRepositoryTree()).values()}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof Te){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;ae.log(`getStashList('${e}')`);const t=await Ft.stash_list(e);return gt.parse(t,e)}async getStatusForFile(e,t){ae.log(`getStatusForFile('${e}', '${t}')`);const i=Ft.validateVersion(2,11)?2:1,s=await Ft.status_file(e,t,i),o=vt.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;ae.log(`getStatusForRepo('${e}')`);const t=Ft.validateVersion(2,11)?2:1,i=await Ft.status(e,t);return vt.parse(i,e,t)}async getTags(e){if(void 0===e)return[];ae.log(`getTags('${e}')`);const t=await Ft.tag(e);return wt.parse(t,e)||[]}async getVersionedFile(e,t,i){if(ae.log(`getVersionedFile('${e}', '${t}', '${i}')`),!i||Ft.isUncommitted(i)&&!Ft.isStagedUncommitted(i))return await this.fileExists(e,t)?t:void 0;const s=await Ft.getVersionedFile(e,t,i);return void 0!==s?(this._versionedUriCache.set(Te.toKey(s),new Te(L.Uri.file(t),{sha:i,repoPath:e,versionedPath:s})),s):void 0}getVersionedFileText(e,t,i){return ae.log(`getVersionedFileText('${e}', '${t}', ${i})`),Ft.show(e,t,i,{encoding:Lt.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(Te.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===V.File||t===V.Git||t===V.GitLensGit}async isTracked(e,t,i={}){if(i.ref===Lt.deletedSha)return!1;let s,o,a=i.ref;if("string"==typeof e)[o,t]=Ft.splitPath(e,t),s=Te.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,a=e.sha,s=Te.toKey(o)}void 0!==a&&(s+=`:${a}`),ae.log(`isTracked('${o}', '${t}', '${a}')`);let r=this._trackedCache.get(s);return void 0!==r?await r:(r=this.isTrackedCore(o,void 0===t?"":t,a),i.skipCacheUpdate?r:(this._trackedCache.set(s,r),r=await r,this._trackedCache.set(s,r),r))}async isTrackedCore(e,t,i){if(i===Lt.deletedSha)return!1;try{let s=!!await Ft.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await Ft.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await Ft.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return ae.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await Ft.config_get("diff.guitool",e)||await Ft.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return ae.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),Ft.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return ae.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),Ft.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return Lt.isResolveRequired(t)?(ae.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),void 0===i?await Ft.revparse(e,t)||t:await Ft.log_resolve(e,y.normalizePath(Se.relative(e,i.fsPath)),t)||t):t}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return ae.log(`stashApply('${e}', '${t}', ${i})`),Ft.stash_apply(e,t,i)}stashDelete(e,t){return ae.log(`stashDelete('${e}', '${t}')`),Ft.stash_delete(e,t)}stashSave(e,t,i){if(ae.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return Ft.stash_save(e,t);const s=i.map(t=>Ft.splitPath(t.fsPath,e)[0]);return Ft.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?L.Uri.file(Se.join(e,t)):e;return Ft.getEncoding(L.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return Ft.getGitInfo(e)}static getGitPath(){return Ft.gitInfo().path}static getGitVersion(){return Ft.gitInfo().version}static isResolveRequired(e){return Ft.isResolveRequired(e)}static isSha(e){return Ft.isSha(e)}static isStagedUncommitted(e){return Ft.isStagedUncommitted(e)}static isUncommitted(e){return Ft.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)",working:""},t),""===e?t.working:e===Lt.deletedSha?t.deleted:Ft.isSha(e)||Ft.isStagedUncommitted(e)?Ft.shortenSha(e,t):e}static validateGitVersion(e,t){const[i,s]=this.getGitVersion().split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}}Lt.emptyPromise=Promise.resolve(void 0),Lt.deletedSha="ffffffffffffffffffffffffffffffffffffffff",Lt.stagedUncommittedSha=Ft.stagedUncommittedSha,Lt.uncommittedSha=Ft.uncommittedSha,function(e){e.ActiveEditorChanged="active-editor-changed",e.AutoRefreshChanged="auto-refresh-changed",e.Command="command",e.ConfigurationChanged="configuration",e.NodeCommand="node-command",e.RepoChanged="repo-changed",e.ViewChanged="view-changed",e.VisibleEditorsChanged="visible-editors-changed"}(Bt||(Bt={})),function(e){e.Branch="gitlens:branch",e.BranchWithTracking="gitlens:branch:tracking",e.Branches="gitlens:branches",e.BranchesWithRemotes="gitlens:branches:remotes",e.CurrentBranch="gitlens:branch:current",e.CurrentBranchWithTracking="gitlens:branch:current:tracking",e.RemoteBranch="gitlens:branch:remote",e.Commit="gitlens:commit",e.CommitOnCurrentBranch="gitlens:commit:current",e.CommitFile="gitlens:file:commit",e.Commits="gitlens:commits",e.ComparisonResults="gitlens:results:comparison",e.FileHistory="gitlens:history-file",e.Folder="gitlens:folder",e.History="gitlens:history",e.Message="gitlens:message",e.Pager="gitlens:pager",e.Remote="gitlens:remote",e.Remotes="gitlens:remotes",e.Repositories="gitlens:repositories",e.Repository="gitlens:repository",e.Results="gitlens:results",e.ResultsCommits="gitlens:results:commits",e.ResultsFiles="gitlens:results:files",e.SearchResults="gitlens:results:search",e.Stash="gitlens:stash",e.StashFile="gitlens:file:stash",e.Stashes="gitlens:stashes",e.Status="gitlens:status",e.StatusFile="gitlens:file:status",e.StatusFiles="gitlens:status:files",e.StatusFileCommits="gitlens:status:file-commits",e.StatusUpstream="gitlens:status:upstream",e.Tag="gitlens:tag",e.Tags="gitlens:tags"}(Nt||(Nt={}));class Ot extends L.Disposable{constructor(e){super(()=>this.dispose()),this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class It extends Ot{get repoPath(){return this.uri.repoPath}}class Mt extends Ot{constructor(e){super(new Te),this.message=e}getChildren(){return[]}getTreeItem(){const e=new L.TreeItem(this.message,L.TreeItemCollapsibleState.None);return e.contextValue=Nt.Message,e}}class Wt extends Ot{constructor(e,t,i){super(new Te),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new L.TreeItem(this.message,L.TreeItemCollapsibleState.None);return e.contextValue=Nt.Pager,e.command=this.getCommand(),e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:Wo.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class Ht extends Wt{constructor(e,t,i){super(`${e} ${Q.Space}${Q.Dash}${Q.Space} this may take a while`,t,i),this.args={maxCount:0}}}class jt extends Ot{constructor(e,t,i,s,o){super(Te.fromRepoPath(e)),this.repoPath=e,this.branchFolderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of s.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new jt(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new L.TreeItem(this.label,L.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Folder,e.resourceUri=this.explorer.folderResourceUri,e}get label(){return this.branchFolderName}}!function(e){e[e.CommitLabel=1]="CommitLabel",e[e.FileLabel=2]="FileLabel",e[e.CommitIcon=4]="CommitIcon",e[e.StatusIcon=8]="StatusIcon",e[e.Gravatar=16]="Gravatar",e[e.File=10]="File"}(At||(At={}));class Gt extends Ot{constructor(e,t,i,s){super(Te.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1,this.repoPath=t.repoPath}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await Wo.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new L.TreeItem(this.label,L.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,(this.displayAs&At.CommitIcon)===At.CommitIcon)e.iconPath={dark:Wo.context.asAbsolutePath(Se.join("images","dark","icon-commit.svg")),light:Wo.context.asAbsolutePath(Se.join("images","light","icon-commit.svg"))};else if((this.displayAs&At.StatusIcon)===At.StatusIcon){const t=tt(this.status.status);e.iconPath={dark:Wo.context.asAbsolutePath(Se.join("images","dark",t)),light:Wo.context.asAbsolutePath(Se.join("images","light",t))}}else(this.displayAs&At.Gravatar)===At.Gravatar&&(e.iconPath=this.commit.getGravatarUri(Wo.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=Se.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&At.CommitLabel?Rt.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dataFormat:Wo.config.defaultDateFormat}):Tt.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get resourceType(){return Nt.CommitFile}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:Ut.DiffWithPrevious,arguments:[Te.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Vt extends Ot{constructor(e,t,i,s,o){super(Te.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(Vt.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==_.List){e=[];for(const t of s.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new Vt(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof Vt?-1:1)-(t instanceof Vt?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new L.TreeItem(this.label,L.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Folder,e.resourceUri=this.explorer.folderResourceUri,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||_.Auto;if(s===_.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return _.List}return _.Tree}return s}}class Qt extends It{constructor(e,t,i){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...f.map(e.fileStatuses,t=>new Gt(t,e.toFileCommit(t),this.explorer,At.File))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>y.normalizePath(Se.join(...e)),this.explorer.config.files.compact),i=new Vt(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){const e=new L.TreeItem(Rt.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:Wo.config.defaultDateFormat}),L.TreeItemCollapsibleState.Collapsed);return e.contextValue=void 0===this.branch||this.branch.current?Nt.CommitOnCurrentBranch:Nt.Commit,this.explorer.config.avatars?e.iconPath=this.commit.getGravatarUri(Wo.config.defaultGravatarsStyle):e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-commit.svg"),light:Wo.context.asAbsolutePath("images/light/icon-commit.svg")},e}getCommand(){return{title:"Compare File with Previous Revision",command:Ut.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Kt extends It{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===F.List?e:Le.isValid(e)&&!this.current?this.branch.getBasename():e}get ref(){return this.branch.name}async getChildren(){const e=await Wo.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.branch.name});if(void 0===e)return[new Mt("No commits yet")];const t=[...f.map(e.commits.values(),e=>new Qt(e,this.explorer,this.branch))];return e.truncated&&t.push(new Ht("Show All Commits",this,this.explorer)),t}async getTreeItem(){let e=this.label;!this.branch.remote&&void 0!==this.branch.tracking&&this.explorer.config.showTrackingBranch&&(e+=` ${Q.Space}${Q.ArrowLeftRight}${Q.Space} ${this.branch.tracking}`);const t=new L.TreeItem(`${this.branch.current?`${Q.Check} ${Q.Space}`:""}${e}`,L.TreeItemCollapsibleState.Collapsed);this.branch.remote?t.contextValue=Nt.RemoteBranch:this.branch.current?t.contextValue=this.branch.tracking?Nt.CurrentBranchWithTracking:Nt.CurrentBranch:t.contextValue=this.branch.tracking?Nt.BranchWithTracking:Nt.Branch;let i="";return this.branch.tracking&&(this.branch.state.ahead&&this.branch.state.behind?i="-yellow":this.branch.state.ahead?i="-green":this.branch.state.behind&&(i="-red")),t.iconPath={dark:Wo.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:Wo.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},t}}class zt extends Ot{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...f.filterMap(e,e=>e.remote?void 0:new Kt(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===F.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),a=new jt(this.repo.path,"",void 0,s,this.explorer),r=await a.getChildren();return void 0!==i&&r.splice(0,0,i),r}async getTreeItem(){const e=new L.TreeItem("Branches",this.active?L.TreeItemCollapsibleState.Expanded:L.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?Nt.BranchesWithRemotes:Nt.Branches,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-branch.svg"),light:Wo.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class qt extends Ot{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...f.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new Kt(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===F.List)return t;const i=o.makeHierarchical(t,e=>e.branch.isValid()?e.branch.getName().split("/"):[e.branch.name],(...e)=>e.join("/"),this.explorer.config.files.compact),s=new jt(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===Ge.Fetch),t=this.remote.types.find(e=>e.type===Ge.Push);let i;i=e&&t?Q.ArrowLeftRight:e?Q.ArrowLeft:t?Q.ArrowRight:Q.Dash;const s=`${this.remote.name} ${Q.Space}${i}${Q.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${Q.Space}${Q.Dot}${Q.Space} ${this.remote.path}`,o=new L.TreeItem(s,L.TreeItemCollapsibleState.Collapsed);return o.contextValue=Nt.Remote,o}}class Yt extends Ot{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new Mt("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...f.map(e,e=>new qt(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new L.TreeItem("Remotes",L.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Remotes,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-remote.svg"),light:Wo.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class Xt extends Ot{constructor(e,t,i,s){super(Te.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new Gt(this.status,e,this.explorer,At.CommitLabel|(this.explorer.config.avatars?At.Gravatar:At.CommitIcon)))}async getTreeItem(){const e=new L.TreeItem(this.label,L.TreeItemCollapsibleState.Collapsed);e.contextValue=Nt.StatusFileCommits;const t=tt(this.status.status);return e.iconPath={dark:Wo.context.asAbsolutePath(Se.join("images","dark",t)),light:Wo.context.asAbsolutePath(Se.join("images","light",t))},1===this.commits.length&&this.commits[0].isUncommitted&&(e.collapsibleState=L.TreeItemCollapsibleState.None,e.contextValue=Nt.StatusFile,e.command=this.getCommand()),this._label=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=Se.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Tt.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getCommand(){return{title:"Compare File with Previous Revision",command:Ut.DiffWithPrevious,arguments:[Te.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Jt extends Ot{constructor(e,t,i,s=!1){super(Te.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.active=s,this.supportsPaging=!0,this.repoPath=e.repoPath}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:files`}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await Wo.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(f.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...f.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new je(Be.File,t,Lt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,Lt.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new je(Be.File,t,Lt.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new je(Be.File,t,Lt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new je(Be.File,t,Lt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const a=o.groupBy(e,e=>e.fileName);let r=[...f.map(s.values(a),e=>new Xt(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(r,e=>e.uri.getRelativePath().split("/"),(...e)=>y.normalizePath(Se.join(...e)),this.explorer.config.files.compact),i=new Vt(t,"",void 0,e,this.explorer);r=await i.getChildren()}else r.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&r.push(new Ht("Show All Changes",this,this.explorer)),r}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream){const t=await Wo.git.getChangedFilesCount(this.repoPath,`${this.status.upstream}...`);void 0!==t&&(e+=t.files)}const t=`${e} file${e>1?"s":""} changed`,i=new L.TreeItem(t,L.TreeItemCollapsibleState.Collapsed);return i.id=this.id,i.contextValue=Nt.StatusFiles,i.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-diff.svg"),light:Wo.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class Zt extends Ot{constructor(e,t,i,s=!1){super(Te.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:upstream`}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.branch}`:`${this.status.branch}..${this.status.upstream}`;let t=await Wo.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...f.map(t.commits.values(),e=>new Qt(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await Wo.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=f.first(t.commits.values())),[...f.map(i,e=>new Qt(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction?`${this.status.state.ahead} commit${this.status.state.ahead>1?"s":""} (ahead of ${this.status.upstream})`:`${this.status.state.behind} commit${this.status.state.behind>1?"s":""} (behind ${this.status.upstream})`,t=new L.TreeItem(e,L.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Nt.StatusUpstream,t.iconPath={dark:Wo.context.asAbsolutePath(`images/dark/icon-${"ahead"===this.direction?"upload":"download"}.svg`),light:Wo.context.asAbsolutePath(`images/light/icon-${"ahead"===this.direction?"upload":"download"}.svg`)},t}}class ei extends Ot{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:status`}async getChildren(){this.resetChildren();const e=await this.repo.getStatus();if(void 0===e)return[];if(this.children=[],e.state.behind&&this.children.push(new Zt(e,"behind",this.explorer,this.active)),e.state.ahead&&this.children.push(new Zt(e,"ahead",this.explorer,this.active)),e.state.ahead||0!==e.files.length&&this.includeWorkingTree){const t=e.upstream?`${e.upstream}..${e.branch}`:void 0;this.children.push(new Jt(e,t,this.explorer,this.active))}return this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new L.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=L.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let s,o="",a="";e.upstream?e.state.ahead||e.state.behind?(o=`${e.branch}${i?" has uncommitted changes and":""} is not up-to-date with ${e.upstream}`,t=!0,e.state.ahead&&e.state.behind?a="-yellow":e.state.ahead?a="-green":e.state.behind&&(a="-red")):o=`${e.branch}${i?" has uncommitted changes and":""} is up-to-date with ${e.upstream}`:o=`${e.branch} ${i?"has uncommitted changes":this.includeWorkingTree?"has no changes":"has nothing to commit"}`,s=t||i?this.active?L.TreeItemCollapsibleState.Expanded:L.TreeItemCollapsibleState.Collapsed:L.TreeItemCollapsibleState.None;const r=new L.TreeItem(o,s);return r.id=this.id,r.contextValue=Nt.Status,r.iconPath={dark:Wo.context.asAbsolutePath(`images/dark/icon-repo${a}.svg`),light:Wo.context.asAbsolutePath(`images/light/icon-repo${a}.svg`)},r}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class ti extends Gt{constructor(e,t,i){super(e,t,i,At.File)}get resourceType(){return Nt.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class ii extends It{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await Wo.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=f.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new ti(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new L.TreeItem(Rt.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dataFormat:Wo.config.defaultDateFormat}),L.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Stash,e}}class si extends Ot{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new Mt("No stashed changes")]:[...f.map(e.commits.values(),e=>new ii(e,this.explorer))]}getTreeItem(){const e=new L.TreeItem("Stashes",L.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Stashes,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-stash.svg"),light:Wo.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class oi extends It{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get ref(){return this.tag.name}async getChildren(){const e=await Wo.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new Mt("No commits yet")];const t=[...f.map(e.commits.values(),e=>new Qt(e,this.explorer))];return e.truncated&&t.push(new Ht("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new L.TreeItem(this.tag.name,L.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Tag,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-tag.svg"),light:Wo.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class ai extends Ot{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){const e=await this.repo.getTags();return 0===e.length?[new Mt("No tags yet")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...e.map(e=>new oi(e,this.uri,this.explorer))])}async getTreeItem(){const e=new L.TreeItem("Tags",L.TreeItemCollapsibleState.Collapsed);return e.contextValue=Nt.Tags,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-tag.svg"),light:Wo.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class ri extends Ot{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}`}async getChildren(){return this.resetChildren(),this.updateSubscription(),this.children=[new ei(this.uri,this.repo,this.explorer,this.active),new zt(this.uri,this.repo,this.explorer,this.active),new Yt(this.uri,this.repo,this.explorer),new si(this.uri,this.repo,this.explorer),new ai(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${y.pad(Q.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new L.TreeItem(e,this.active?L.TreeItemCollapsibleState.Expanded:L.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Nt.Repository,t}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||L.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(ae.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(Ve.Repository)||e.changed(Ve.Config))this.explorer.refreshNode(this);else{if(e.changed(Ve.Stashes)){const e=this.children.find(e=>e instanceof si);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(Ve.Remotes)){const e=this.children.find(e=>e instanceof Yt);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(Ve.Tags)){const e=this.children.find(e=>e instanceof ai);void 0!==e&&this.explorer.refreshNode(e)}}}}class ni extends Ot{constructor(e){super(void 0),this.explorer=e,Wo.context.subscriptions.push(L.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(L.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}get id(){return"gitlens:repository:active"}async onActiveEditorChanged(e){if(void 0!==e&&!X(e))return;let t=!1;try{const i=await Wo.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await Wo.git.getRepository(i);if(void 0===s)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new ri(Te.fromRepoPath(s.path),s,this.explorer,!0)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){const e=void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new L.TreeItem("No active repository",L.TreeItemCollapsibleState.None);return e.id=this.id,e}}class hi extends Ot{constructor(e,t,i=Nt.Results){super(e.toGitUri()),this.commit=e,this.explorer=t,this.contextValue=i}async getChildren(){const e=await new Qt(this.commit,this.explorer).getChildren();return e.splice(0,0,new Mt(Rt.fromTemplate("${message}",this.commit,{truncateMessageAtNewLine:!1}))),e}async getTreeItem(){const e=Rt.fromTemplate(`Commit \${sha} ${y.pad(Q.Dash,1,1)} \${authorAgo}`,this.commit,Wo.config.defaultDateFormat),t=new L.TreeItem(e,L.TreeItemCollapsibleState.Expanded);return t.contextValue=this.contextValue,t}}class ci extends Ot{constructor(e,t,i,s,o=Nt.ResultsCommits){super(Te.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...f.map(e.commits.values(),e=>new Qt(e,this.explorer))];return e.truncated&&t.push(new Ht("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new L.TreeItem(await this.getLabel(),e&&e.count>0?L.TreeItemCollapsibleState.Expanded:L.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class li extends Ot{constructor(e,t,i,s,o){super(Te.fromFileStatus(t,e)),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new L.TreeItem(this.label,L.TreeItemCollapsibleState.None);e.contextValue=Nt.StatusFile;const t=tt(this.status.status);return e.iconPath={dark:Wo.context.asAbsolutePath(Se.join("images","dark",t)),light:Wo.context.asAbsolutePath(Se.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=Se.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Tt.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:Ut.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?Te.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class di extends Ot{constructor(e,t,i,s,o,a){super(Te.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.labelFn=s,this.diffFn=o,this.explorer=a,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...f.map(e,e=>new li(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==_.List){const e=o.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>y.normalizePath(Se.join(...e)),this.explorer.config.files.compact),i=new Vt(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new L.TreeItem(await this.getLabel(),e&&e.length>0?L.TreeItemCollapsibleState.Expanded:L.TreeItemCollapsibleState.None);return t.contextValue=Nt.ResultsFiles,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.diffFn();this._cache={label:this.labelFn(e),diff:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getDiff(){return(await this.ensureCache()).diff}}class mi extends Ot{constructor(e,t,i,s){super(Te.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){this.resetChildren();return this.children=[new ci(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return 1===t?"1 commit":`${0===t?"No":`${t}${i?"+":""}`} commits`},e=>Wo.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1}...${this.ref2||"HEAD"}`}),this.explorer),new di(this.uri.repoPath,this.ref1,this.ref2,e=>{const t=void 0!==e?e.length:0;return 1===t?"1 file changed":`${0===t?"No":t} files changed`},()=>Wo.git.getDiffStatus(this.uri.repoPath,this.ref1,this.ref2),this.explorer)],this.children}async getTreeItem(){let e="";if(await Wo.git.getRepositoryCount()>1){const t=await Wo.git.getRepository(this.uri.repoPath);e=` ${y.pad(Q.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new L.TreeItem(`Comparing ${Lt.shortenSha(this.ref1,{working:"Working Tree"})} to ${Lt.shortenSha(this.ref2,{working:"Working Tree"})}${e}`,L.TreeItemCollapsibleState.Expanded);return t.contextValue=Nt.ComparisonResults,t}}class ui extends Ot{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=At.CommitLabel|(this.explorer.config.avatars?At.Gravatar:At.StatusIcon),i=await Wo.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=Lt.uncommittedSha,void 0!==i.indexStatus?o=Lt.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=Lt.stagedUncommittedSha,o="HEAD");const a=new je(Be.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new Gt(i,a,this.explorer,t))}const s=await Wo.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...f.map(s.commits.values(),e=>new Gt(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new Mt("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new L.TreeItem(`${this.uri.getFormattedPath()}`,L.TreeItemCollapsibleState.Expanded);return e.contextValue=Nt.FileHistory,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-history.svg"),light:Wo.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||L.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){e.changed(Ve.Repository)&&(ae.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}}class gi extends Ot{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new ui(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new L.TreeItem(`${this.uri.getFormattedPath()}`,L.TreeItemCollapsibleState.Expanded);return e.contextValue=Nt.History,e.iconPath={dark:Wo.context.asAbsolutePath("images/dark/icon-history.svg"),light:Wo.context.asAbsolutePath("images/light/icon-history.svg")},e}}class pi extends Ot{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return this.resetChildren(),this.children=this.repositories.sort((e,t)=>e.index-t.index).map(e=>new ri(Te.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new ni(this.explorer)),this.children}getTreeItem(){const e=new L.TreeItem("Repositories",L.TreeItemCollapsibleState.Expanded);return e.contextValue=Nt.Repositories,e}}function fi(e,t){return e instanceof L.Uri?e:void 0!==t&&void 0!==t.document?t.document.uri:void 0}function vi(e){return"view"===e.type&&e.node.branch&&e.node.branch instanceof Le}function wi(e){return"view"===e.type&&e.node.commit&&e.node.commit instanceof Ae}function Ci(e){return"view"===e.type&&e.node.remote&&e.node.remote instanceof Ke}function bi(e){return void 0!==e&&(void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates))}function yi(e){return void 0!==e&&void 0!==e.resourceUri}!function(e){e.ClearFileAnnotations="gitlens.clearFileAnnotations",e.CloseUnchangedFiles="gitlens.closeUnchangedFiles",e.ComputingFileAnnotations="gitlens.computingFileAnnotations",e.CopyMessageToClipboard="gitlens.copyMessageToClipboard",e.CopyShaToClipboard="gitlens.copyShaToClipboard",e.DiffDirectory="gitlens.diffDirectory",e.DiffHeadWithBranch="gitlens.diffHeadWithBranch",e.DiffWorkingWithBranch="gitlens.diffWorkingWithBranch",e.ExternalDiffAll="gitlens.externalDiffAll",e.DiffWith="gitlens.diffWith",e.DiffWithBranch="gitlens.diffWithBranch",e.DiffWithNext="gitlens.diffWithNext",e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffLineWithPrevious="gitlens.diffLineWithPrevious",e.DiffWithRevision="gitlens.diffWithRevision",e.DiffWithWorking="gitlens.diffWithWorking",e.DiffLineWithWorking="gitlens.diffLineWithWorking",e.ExternalDiff="gitlens.externalDiff",e.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",e.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",e.OpenChangedFiles="gitlens.openChangedFiles",e.OpenBranchesInRemote="gitlens.openBranchesInRemote",e.OpenBranchInRemote="gitlens.openBranchInRemote",e.OpenCommitInRemote="gitlens.openCommitInRemote",e.OpenFileInRemote="gitlens.openFileInRemote",e.OpenFileRevision="gitlens.openFileRevision",e.OpenInRemote="gitlens.openInRemote",e.OpenRepoInRemote="gitlens.openRepoInRemote",e.OpenWorkingFile="gitlens.openWorkingFile",e.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",e.ShowCommitSearch="gitlens.showCommitSearch",e.ShowFileBlame="gitlens.showFileBlame",e.ShowLastQuickPick="gitlens.showLastQuickPick",e.ShowLineBlame="gitlens.showLineBlame",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",e.ShowQuickStashList="gitlens.showQuickStashList",e.ShowSettingsPage="gitlens.showSettingsPage",e.ShowWelcomePage="gitlens.showWelcomePage",e.StashApply="gitlens.stashApply",e.StashDelete="gitlens.stashDelete",e.StashSave="gitlens.stashSave",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame",e.ToggleFileHeatmap="gitlens.toggleFileHeatmap",e.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",e.ToggleLineBlame="gitlens.toggleLineBlame"}(Ut||(Ut={}));class xi extends L.Disposable{constructor(e){if(super(()=>this.dispose()),this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=L.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>L.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=L.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=xi.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let s=void 0,o=i[0];if(t.editor&&(void 0===o||function(e){return void 0!==e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(o))&&(s=o,o=(i=i.slice(1))[0]),t.uri&&(void 0===o||o instanceof L.Uri)){const[t,...o]=i;return[{command:e,type:"uri",editor:s,uri:t},o]}if(o instanceof Ot){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if(yi(o)){const t=[];let s=0;for(const e of i){if(!yi(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(bi(o)){const t=[];let s=0;for(const e of i){if(!bi(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:s},i]}}class Si extends xi{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,L.window.activeTextEditor,...t)}}let $i=void 0;class Di extends Si{constructor(e){super(e)}_execute(e,...t){return $i={command:e,args:t},super._execute(e,...t)}}class ki extends L.Disposable{constructor(e){super(()=>this.dispose()),Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(L.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=L.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function Pi(e,t={}){const{rethrow:i}=t,s=m.__rest(t,["rethrow"]);try{e instanceof Te&&(e=e.fileUri({noSha:!0}));const t=await L.workspace.openTextDocument(e);return L.window.showTextDocument(t,Object.assign({preserveFocus:!1,preview:!0,viewColumn:L.ViewColumn.Active},s))}catch(e){if(i)throw e;return void ae.error(e,"openEditor")}}class Fi extends ki{constructor(){super([Ut.ClearFileAnnotations,Ut.ComputingFileAnnotations])}async execute(e,t,i){if(void 0!==e){if(void 0!==i&&!te.equals(i,e.document.uri)){const t=L.window.visibleTextEditors.find(e=>te.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return Wo.annotations.clear(e)}catch(e){return ae.error(e,"ClearFileAnnotationsCommand"),L.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class _i extends L.Disposable{constructor(){super(()=>this.dispose());const e=p.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=L.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return L.commands.executeCommand(j.CloseActiveEditor)}async next(){return L.commands.executeCommand(j.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let s;this._resolver=(e=>{s&&(clearTimeout(s),s=0,t(e))}),s=setTimeout(()=>{t(L.window.activeTextEditor),s=0},e)});return this._resolver=void 0,t}}var Ri;!function(e){e.CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",e.CommitNotFoundWarning="suppressCommitNotFoundWarning",e.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",e.GitVersionWarning="suppressGitVersionWarning",e.LineUncommittedWarning="suppressLineUncommittedWarning",e.NoRepositoryWarning="suppressNoRepositoryWarning",e.ResultsExplorerNotice="suppressResultsExplorerNotice"}(Ri||(Ri={}));class Ti{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?Ti.showMessage("info","Commit has no previous commit",Ri.CommitHasNoPreviousCommitWarning):Ti.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit`,Ri.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return Ti.showMessage("warn",`${e}. The commit could not be found`,Ri.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return Ti.showMessage("warn",`${e}. The file is probably not under source control`,Ri.FileNotUnderSourceControlWarning)}static showLineUncommittedWarningMessage(e){return Ti.showMessage("warn",`${e}. The line has uncommitted changes`,Ri.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return Ti.showMessage("warn",`${e}. No repository could be found`,Ri.NoRepositoryWarning)}static showResultExplorerInfoMessage(){return Ti.showMessage("info",'If you can\'t find your results, click on "GITLENS RESULTS" at the bottom of the Explorer view',Ri.ResultsExplorerNotice,null)}static showUnsupportedGitVersionErrorMessage(e){return Ti.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git`,Ri.GitVersionWarning)}static async showMessage(e,t,i,s="Don't Show Again",...o){if(ae.log(`ShowMessage(${e}, '${t}', ${i}, ${s})`),Go.get(Go.name("advanced")("messages")(i).value))return void ae.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) skipped`);null!==s&&o.push(s);let a=void 0;switch(e){case"info":a=await L.window.showInformationMessage(t,...o);break;case"warn":a=await L.window.showWarningMessage(t,...o);break;case"error":a=await L.window.showErrorMessage(t,...o)}if(null===s||a===s){ae.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) don't show again requested`);const o=Go.name("advanced")("messages").value,r=Go.get(o);if(r[i]=!0,await Go.update(o,r,L.ConfigurationTarget.Global),a===s)return}return ae.log(`ShowMessage(${e}, '${t}', ${i}, ${s}) returned ${a}`),a}}class Ei extends Si{constructor(){super(Ut.CloseUnchangedFiles)}async execute(e,t,i={}){t=fi(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to close unchanged files");const s=await Wo.git.getStatusForRepo(e);if(void 0===s)return L.window.showWarningMessage("Unable to close unchanged files");i.uris=s.files.map(e=>e.uri)}if(0===i.uris.length)return L.commands.executeCommand(j.CloseAllEditors);const e=new _i;let s=0,o=void 0,a=L.window.activeTextEditor;for(;;){if(void 0!==a){if(ee.equals(o,a,{useId:!0,usePosition:!0}))break;if(void 0!==a.document&&(a.document.isDirty||i.uris.some(e=>te.equals(e,a.document&&a.document.uri)))){const t=o;if(o=a,a=await e.awaitNext(500),ee.equals(t,a,{useId:!0,usePosition:!0}))break;continue}}if(o=a,a=await e.awaitClose(500),void 0===o&&void 0===a){if(++s>=4)break}else s=0}return void e.dispose()}catch(e){return ae.error(e,"CloseUnchangedFilesCommand"),L.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class Bi extends Si{constructor(){super(Ut.CopyMessageToClipboard)}async preExecute(e,t={}){return wi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=fi(t,e);const o=await new Promise(function(e){e()}).then(i.bind(null,13));try{if(s=Object.assign({},s),void 0===t){const t=await Wo.git.getActiveRepoPath(e);if(!t)return;const i=await Wo.git.getLog(t,{maxCount:1});if(!i)return;return s.message=f.first(i.commits.values()).message,void o.copy(s.message)}const i=await Te.fromUri(t);if(void 0===s.message){if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(i,t,e.document.getText()):await Wo.git.getBlameForLine(i,t);if(!o)return;if(o.commit.isUncommitted)return;s.sha=o.commit.sha,i.repoPath||(i.repoPath=o.commit.repoPath)}catch(e){return ae.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),L.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const t=await Wo.git.getLogCommit(i.repoPath,s.sha);if(void 0===t)return;s.message=t.message}return void o.copy(s.message,e=>{if(e){if(e.message.includes("xclip"))return void L.window.showErrorMessage("Unable to copy message, xclip is not installed. You can install it via `sudo apt-get install xclip`");ae.error(e,"CopyMessageToClipboardCommand"),L.window.showErrorMessage("Unable to copy message. See output channel for more details")}})}catch(e){return ae.error(e,"CopyMessageToClipboardCommand"),L.window.showErrorMessage("Unable to copy message. See output channel for more details")}}}class Ni extends Si{constructor(){super(Ut.CopyShaToClipboard)}async preExecute(e,t={}){return wi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,s={}){t=fi(t,e);const o=await new Promise(function(e){e()}).then(i.bind(null,13));try{if(s=Object.assign({},s),void 0===t){const t=await Wo.git.getActiveRepoPath(e);if(!t)return;const i=await Wo.git.getLog(t,{maxCount:1});if(!i)return;return s.sha=f.first(i.commits.values()).sha,void o.copy(s.sha)}const i=await Te.fromUri(t);if(void 0===s.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(i,t,e.document.getText()):await Wo.git.getBlameForLine(i,t);if(void 0===o)return;s.sha=o.commit.sha}catch(e){return ae.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${t})`),L.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void o.copy(s.sha,e=>{if(e){if(e.message.includes("xclip"))return void L.window.showErrorMessage("Unable to copy commit id, xclip is not installed. You can install it via `sudo apt-get install xclip`");ae.error(e,"CopyShaToClipboardCommand"),L.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}})}catch(e){return ae.error(e,"CopyShaToClipboardCommand"),L.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}}const Ai=Object.create(null),Ui=["left","right",",",".","escape"],Li=[];class Oi extends L.Disposable{constructor(e){super(()=>this.dispose()),this.mapping=e;for(const t in e)e[t]=e[t]||Ai}async dispose(){const e=Li.indexOf(this.mapping);ae.log("KeyboardScope.dispose",Li.length,e),e===Li.length-1?(Li.pop(),await this.updateKeyCommandsContext(Li[Li.length-1])):Li.splice(e,1)}async begin(){return Li.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=Li[Li.length-1];t===this.mapping&&t[e]&&(ae.log("KeyboardScope.clearKeyCommand",Li.length,e),t[e]=void 0,await q(`${G.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=Li[Li.length-1];i===this.mapping&&(ae.log("KeyboardScope.setKeyCommand",Li.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await q(`${G.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of Ui)t.push(q(`${G.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class Ii extends L.Disposable{constructor(){super(()=>this.dispose());const e=Ui.map(e=>L.commands.registerCommand(`${O}.key.${e}`,()=>this.execute(e),this));this._disposable=L.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return ae.log("Keyboard.beginScope",Li.length),await new Oi(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(Li.length)try{let t=Li[Li.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return ae.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void ae.error(e,"Keyboard.execute")}}}class Mi{constructor(e){this.branchOrTag=e,e instanceof Le?(this.label=`${e.current?`$(check)${Q.Space}`:Q.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${Q.Space.repeat(2)} remote branch`:""):(this.label=`${Q.Space.repeat(4)} ${e.name}`,this.description=`${Q.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Le&&this.branchOrTag.remote}}class Wi{static showProgress(e){return ji(e,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s={}){const o=[...e.filter(e=>!e.remote).map(e=>new Mi(e)),...t.map(e=>new Mi(e)),...e.filter(e=>e.remote).map(e=>new Mi(e))];if(void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const a=await Wo.keyboard.beginScope({left:s.goBackCommand||Ai});s.progressCancellation&&s.progressCancellation.cancel();const r=await L.window.showQuickPick(o,{placeHolder:i,ignoreFocusOut:Hi()});return await a.dispose(),r}}function Hi(){return!Go.get(Go.name("advanced")("quickPick")("closeOnFocusOut").value)}function ji(e,t){const i=new L.CancellationTokenSource;return async function(e,t,i){const s=i&&await Wo.keyboard.beginScope(i);try{await L.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:Hi()},t.token)}catch(e){}finally{t.cancel(),s&&s.dispose()}}(e,i,t),i}class Gi{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):L.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class Vi extends Gi{constructor(e){super({label:e,description:""})}}class Qi extends Gi{constructor(e,t){super({label:"",description:""},e,t)}}class Ki extends Gi{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return Pi(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class zi extends Gi{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await Pi(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class qi{constructor(e){this.commit=e;let t=e.message;const i=t.indexOf("\n");-1!==i&&(t=`${t.substring(0,i)}${Q.Space}$(ellipsis)`),e.isStash?(this.label=t,this.description="",this.detail=`${Q.Space} ${e.stashName||e.shortSha} ${y.pad(Q.Dot,1,1)} ${e.formattedDate} ${y.pad(Q.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${y.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${Q.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${y.pad(Q.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class Yi extends Gi{constructor(e,t={label:"Show in Results",description:`${y.pad(Q.Dash,2,2)} displays commit in the GitLens Results view`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){Wo.resultsExplorer.showCommitInResults(this.commit)}}class Xi extends Gi{constructor(e,t,i={label:"Show in Results",description:`${y.pad(Q.Dash,2,2)} displays commits in the GitLens Results view`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){Wo.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class Ji extends Xi{constructor(e,t,i={label:"Show in Results",description:`${y.pad(Q.Dash,2,2)} displays results in the GitLens Results view`}){super(e,{label:t},i),this.results=e,this.search=t}}class Zi extends Gi{constructor(e,t,i,s={label:"Show Branches and Tags",description:`${y.pad(Q.Dash,2,2)} displays branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=Wi.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([Wo.git.getBranches(this.repoPath),Wo.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return Wi.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.dispose()}}}class es{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${Q.Space}`:Q.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${Q.Space.repeat(2)} remote branch`:""}}class ts{static async show(e,t,i={}){const s=e.map(e=>new es(e));return void 0!==i.goBackCommand&&s.splice(0,0,i.goBackCommand),await L.window.showQuickPick(s,{placeHolder:t,ignoreFocusOut:Hi()})}}class is extends Gi{constructor(e,t){super({label:`$(link-external) Open ${me(t)} in ${e.provider.name}`,description:`${y.pad(Q.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.remote=e,this.resource=t}async execute(){return this.remote.provider.open(this.resource)}}class ss extends Gi{constructor(e,t,i){const s=me(t);let o="";switch(t.type){case de.Branch:o=`$(git-branch) ${t.branch}`;break;case de.Branches:o="$(git-branch) Branches";break;case de.Commit:o=`$(git-commit) ${Lt.shortenSha(t.sha)}`;break;case de.File:o=`$(file-text) ${Se.basename(t.fileName)}`;break;case de.Repo:o="$(repo) Repository";break;case de.Revision:if(void 0!==t.commit&&t.commit instanceof je)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${Se.basename(t.fileName)} in ${Q.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${Q.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${Se.basename(t.fileName)} in ${Q.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":Lt.shortenSha(t.sha);o=`$(file-text) ${Se.basename(t.fileName)}${e?` in ${Q.Space}$(git-commit) ${e}`:""}`}}const a=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===a.provider.name)?a.provider.name:"Remote"}${Q.Ellipsis}`,description:`${y.pad(Q.Dash,2,3)} ${o}`},Ut.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${a.provider.name}`,description:`${y.pad(Q.Dash,2,3)} $(repo) ${a.provider.path} ${y.pad(Q.Dot,1,1)} ${o}`},Ut.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class os{static async show(e,t,i,s){const o=e.map(e=>new is(e,i));s&&o.splice(0,0,s);const a=await L.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:Hi()});if(void 0!==a)return a}}class as extends Ki{constructor(e,t){const i=Ze(t.status),s=Xe.getFormattedDirectory(t,!0);super(Te.toRevisionUri(e.sha,t,e.repoPath),{label:`${y.pad(i,4,2)} ${Se.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):L.commands.executeCommand(Ut.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class rs extends zi{constructor(e,t=!1,i){const s=e.repoPath;super(o.filterMap(e.fileStatuses,e=>Te.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class ns extends zi{constructor(e,t){super(o.filterMap(e.fileStatuses,t=>Te.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${y.pad(Q.Dash,2,3)} in ${Q.Space}$(git-commit) ${e.shortSha}`})}}class hs{static async show(e,t,i,s,o){await e.resolvePreviousFileSha();const a=e.fileStatuses.map(t=>new as(e,t)),r=e.isStash;let n=0;if(r)a.splice(n++,0,new Gi({label:"$(git-pull-request) Apply Stashed Changes",description:`${y.pad(Q.Dash,2,3)} ${e.message}`},Ut.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:s}])),a.splice(n++,0,new Gi({label:"$(x) Delete Stashed Changes",description:`${y.pad(Q.Dash,2,3)} ${e.message}`},Ut.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:s}])),a.splice(n++,0,new Yi(e));else{a.splice(n++,0,new Yi(e));const t=(await Wo.git.getRemotes(e.repoPath)).filter(e=>void 0!==e.provider);t.length&&a.splice(n++,0,new ss(t,{type:"commit",sha:e.sha},s))}a.splice(n++,0,new rs(e)),a.splice(n++,0,new ns(e)),a.splice(n++,0,new Gi({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${Q.Space} $(git-compare) ${Q.Space} $(git-commit) ${e.shortSha}`},Ut.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),a.splice(n++,0,new Gi({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.shortSha} ${Q.Space} $(git-compare) ${Q.Space} $(file-directory) Working Tree`},Ut.DiffDirectory,[t,{ref1:e.sha}])),r||a.splice(n++,0,new Gi({label:"$(clippy) Copy Commit ID to Clipboard",description:`${y.pad(Q.Dash,2,3)} ${e.shortSha}`},Ut.CopyShaToClipboard,[t,{sha:e.sha}])),a.splice(n++,0,new Gi({label:"$(clippy) Copy Commit Message to Clipboard",description:`${y.pad(Q.Dash,2,3)} ${e.message}`},Ut.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),a.splice(n++,0,new Gi({label:"Changed Files",description:e.getDiffStatus()},Ut.ShowQuickCommitDetails,[t,{commit:e,repoLog:o,sha:e.sha,goBackCommand:i}])),i&&a.splice(0,0,i);let h=void 0,c=void 0;r||(void 0===o||o.truncated||void 0!==o.sha?(h=(async()=>{let t=o,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await Wo.git.getLog(e.repoPath,{maxCount:Wo.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?Ai:new Qi(Ut.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),c=(async()=>{let t=o,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await Wo.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&f.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?Ai:new Qi(Ut.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(h=void 0===e.previousSha?void 0:new Qi(Ut.ShowQuickCommitDetails,[e.previousUri,{repoLog:o,sha:e.previousSha,goBackCommand:i}]),c=void 0===e.nextSha?void 0:new Qi(Ut.ShowQuickCommitDetails,[e.nextUri,{repoLog:o,sha:e.nextSha,goBackCommand:i}])));const l=await Wo.keyboard.beginScope({left:i,",":h,".":c}),d=await L.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${y.pad(Q.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${y.pad(Q.Dot,1,1)} ${e.message}`,ignoreFocusOut:Hi(),onDidSelectItem:e=>{l.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await l.dispose(),d}}class cs extends Gi{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${y.pad(Q.Dash,2,3)} $(file-text) ${Se.basename(e.fileName)} in ${Q.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await Wo.git.checkoutFile(e),Pi(e,{preserveFocus:!0,preview:!1})}}class ls extends Ki{constructor(e,t){super(L.Uri.file(Se.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${y.pad(Q.Dash,2,3)} ${Se.basename(e.fileName)}`})}}class ds extends Ki{constructor(e,t){let i,s;"D"===e.status?(s=Te.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${y.pad(Q.Dash,2,3)} ${Se.basename(e.fileName)} in ${Q.Space}$(git-commit) ${e.previousShortSha} (deleted in ${Q.Space}$(git-commit) ${e.shortSha})`):(s=Te.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${y.pad(Q.Dash,2,3)} ${Se.basename(e.fileName)} in ${Q.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class ms{static async show(e,t,i,s,o){const a=[],r=e.isStash,n=e.workingFileName&&Se.basename(e.workingFileName)||Se.basename(e.fileName),h=e.isUncommitted;if(h){const t=await Wo.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),r&&a.push(new cs(e)),e.previousFileShortSha&&a.push(new Gi({label:"$(git-compare) Open Changes",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${Q.Space} $(git-compare) ${Q.Space} $(git-commit) ${e.shortSha}`},Ut.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&a.push(new Gi({label:"$(git-compare) Open Changes with Working Tree",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.shortSha} ${Q.Space} $(git-compare) ${Q.Space} $(file-text) ${n}`},Ut.DiffWithWorking,[L.Uri.file(Se.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&a.push(new ls(e)),a.push(new ds(e));const c=(await Wo.git.getRemotes(e.repoPath)).filter(e=>void 0!==e.provider);if(c.length){if(e.workingFileName&&"D"!==e.status){const t=await Wo.git.getBranch(e.repoPath);a.push(new ss(c,{type:"file",fileName:e.workingFileName,branch:t.name},s))}r||a.push(new ss(c,{type:"revision",fileName:e.fileName,commit:e},s))}r||(a.push(new cs(e)),a.push(new Gi({label:"$(clippy) Copy Commit ID to Clipboard",description:`${y.pad(Q.Dash,2,3)} ${e.shortSha}`},Ut.CopyShaToClipboard,[t,{sha:e.sha}])),a.push(new Gi({label:"$(clippy) Copy Commit Message to Clipboard",description:`${y.pad(Q.Dash,2,3)} ${e.message}`},Ut.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&a.push(new Gi({label:"$(history) Show File History",description:`${y.pad(Q.Dash,2,3)} of ${Se.basename(e.fileName)}`},Ut.ShowQuickFileHistory,[L.Uri.file(Se.resolve(e.repoPath,e.workingFileName)),{fileLog:o,goBackCommand:s}])),r||(a.push(new Gi({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${y.pad(Q.Dash,2,3)} of ${Se.basename(e.fileName)} ${y.pad(Q.Dot,1,1)} from ${Q.Space}$(git-commit) ${e.shortSha}`},Ut.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:s}])),a.push(new Gi({label:"$(git-commit) Show Commit Details",description:`${y.pad(Q.Dash,2,3)} $(git-commit) ${e.shortSha}`},Ut.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:s}]))),i&&a.splice(0,0,i);let l=void 0,d=void 0;r||(void 0===o||o.truncated||void 0!==o.sha?(l=(async()=>{let s=o,a=s&&s.commits.get(e.sha);if(void 0===a||void 0===a.previousSha){if(void 0===(s=await Wo.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:Wo.config.advanced.maxListItems,ref:e.sha,renames:!0})))return Ai;void 0===(a=s&&s.commits.get(e.sha))&&e.isMerge&&(a=f.first(s.commits.values())),a&&(a.nextSha=e.nextSha,a.nextFileName=e.nextFileName)}return void 0===a||void 0===a.previousSha?Ai:new Qi(Ut.ShowQuickCommitFileDetails,[a.previousUri,{fileLog:s,sha:a.previousSha,goBackCommand:i}])}),d=(async()=>{let s=o,a=s&&s.commits.get(e.sha);if(void 0===a||void 0===a.nextSha){s=void 0,a=void 0;const i=await Wo.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((a=e).nextSha=i.sha,a.nextFileName=i.originalFileName||i.fileName)}return void 0===a||void 0===a.nextSha?Ai:new Qi(Ut.ShowQuickCommitFileDetails,[a.nextUri,{fileLog:s,sha:a.nextSha,goBackCommand:i}])})):(l=void 0===e.previousSha?void 0:new Qi(Ut.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:o,sha:e.previousSha,goBackCommand:i}]),d=void 0===e.nextSha?void 0:new Qi(Ut.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:o,sha:e.nextSha,goBackCommand:i}])));const m=await Wo.keyboard.beginScope({left:i,",":l,".":d}),u=await L.window.showQuickPick(a,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${y.pad(Q.Dot,1,1)} ${h?`Uncommitted ${Q.ArrowRightHollow} `:""}${e.shortSha} ${y.pad(Q.Dot,1,1)} ${e.author}, ${e.formattedDate} ${y.pad(Q.Dot,1,1)} ${e.message}`,ignoreFocusOut:Hi(),onDidSelectItem:e=>{m.setKeyCommand("right",e)}});return await m.dispose(),u}}class us{static showProgress(e){return ji(e,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s){const o=e&&[...f.map(e.commits.values(),e=>new qi(e))]||[new Vi("No results found")];if(void 0!==s.showInResultsExplorerCommand&&o.splice(0,0,s.showInResultsExplorerCommand),void 0!==s.showAllCommand&&o.splice(0,0,s.showAllCommand),void 0!==s.goBackCommand&&o.splice(0,0,s.goBackCommand),i.token.isCancellationRequested)return;const a=await Wo.keyboard.beginScope({left:s.goBackCommand});i.cancel();const r=await L.window.showQuickPick(o,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:Hi()});return await a.dispose(),r}}class gs{static showProgress(e){return ji(`${e} history ${Q.Dash} search by commit message, filename, or commit id`,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s,o,a){const r=Array.from(f.map(e.commits.values(),e=>new qi(e))),n=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to ${Q.Space}$(git-branch) ${i} history`},Ut.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:o}]),h=(await Wo.git.getRemotes(t&&t.repoPath||e.repoPath)).filter(e=>void 0!==e.provider);h.length&&r.splice(0,0,new ss(h,{type:"branch",branch:i},n)),r.splice(0,0,new Gi({label:"$(search) Show Commit Search",description:`${y.pad(Q.Dash,2,3)} search for commits by message, author, files, or commit id`},Ut.ShowCommitSearch,[Te.fromRepoPath(e.repoPath),{goBackCommand:n}]));let c=void 0;if((e.truncated||e.sha)&&(e.truncated&&r.splice(0,0,new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:o}])),a&&r.splice(0,0,a),e.truncated)){const s=new Gi({label:"$(arrow-right) Show Next Commits",description:`${y.pad(Q.Dash,2,3)} shows ${e.maxCount} newer commits`},Ut.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:a}]),n=f.last(e.commits.values());null!=n&&(c=new Gi({label:"$(arrow-left) Show Previous Commits",description:`${y.pad(Q.Dash,2,3)} shows ${e.maxCount} older commits`},Ut.ShowQuickBranchHistory,[new Te(t||n.uri,n),{branch:i,maxCount:e.maxCount,goBackCommand:o,nextPageCommand:s}]),r.splice(0,0,c))}if(o&&r.splice(0,0,o),s.token.isCancellationRequested)return;const l=await Wo.keyboard.beginScope({left:o,",":c,".":a});s.cancel();const d=await L.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${Q.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:Hi()});return await l.dispose(),d}}class ps{static showProgress(e){return ji(e,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s={}){s=Object.assign({pickerOnly:!1},s);const o=Array.from(f.map(e.commits.values(),e=>new qi(e)));let a=0;if(s.pickerOnly&&(a++,o.splice(0,0,new Zi(e.repoPath,i,s.currentCommand))),void 0!==s.showInResultsExplorerCommand&&(a++,o.splice(0,0,s.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==s.showAllCommand)a++,o.splice(0,0,s.showAllCommand);else if(!s.pickerOnly){const[i]=await Wo.git.findWorkingFileName(Se.relative(e.repoPath,t.fsPath),e.repoPath);i&&(a++,o.splice(0,0,new Gi({label:"$(history) Show File History",description:`${y.pad(Q.Dash,2,3)} of ${Se.basename(i)}`},Ut.ShowQuickFileHistory,[L.Uri.file(Se.resolve(e.repoPath,i)),{goBackCommand:new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${Se.basename(t.fsPath)}${t.sha?` from ${Q.Space}$(git-commit) ${t.shortSha}`:""}`},Ut.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:s.goBackCommand}])}])))}void 0!==s.nextPageCommand&&(a++,o.splice(0,0,s.nextPageCommand)),void 0!==s.previousPageCommand&&(a++,o.splice(0,0,s.previousPageCommand))}if(!s.pickerOnly){const i=await Wo.git.getBranch(t.repoPath),r=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${Se.basename(t.fsPath)}${t.sha?` from ${Q.Space}$(git-commit) ${t.shortSha}`:""}`},Ut.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===s.goBackCommand&&o.splice(a++,0,new Gi({label:"$(history) Show Branch History",description:`${y.pad(Q.Dash,2,3)} shows  ${Q.Space}$(git-branch) ${i.name} history`},Ut.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:r}]));const n=(await Wo.git.getRemotes(t.repoPath)).filter(e=>void 0!==e.provider);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};o.splice(a++,0,new ss(n,e,r))}s.goBackCommand&&o.splice(0,0,s.goBackCommand)}if(void 0!==s.progressCancellation&&s.progressCancellation.token.isCancellationRequested)return;const r=await Wo.keyboard.beginScope({left:s.goBackCommand,",":s.previousPageCommand,".":s.nextPageCommand});s.progressCancellation&&s.progressCancellation.cancel();const n=await L.window.showQuickPick(o,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:Hi()});return await r.dispose(),n}}class fs{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class vs{static async show(e,t){const i=[...f.map(await Wo.git.getRepositories(),e=>new fs(e))];return void 0!==t&&i.splice(0,0,t),await L.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:Hi()})}}class ws extends Ki{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":Q.Space.repeat(3)}${y.pad(s,2,2)} ${Se.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new je(Be.File,e.repoPath,Lt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new je(Be.File,e.repoPath,Lt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?Lt.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return L.commands.executeCommand(Ut.DiffWithPrevious,Te.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class Cs extends Gi{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},Ut.OpenChangedFiles,[void 0,{uris:i}])}}class bs{static computeStatus(e){let t=0,i=0,s=0,o=0,a=0,r=0;const n=[],h=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":a++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,h.push(c);break;case"D":r++;break;case void 0:break;default:o++,h.push(c)}}const c=t+s+a,l=i+o+r;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${a}`:"",stagedAddsAndChanges:n,unstaged:l,unstagedStatus:l>0?`+${i} ~${o} -${r}`:"",unstagedAddsAndChanges:h}}static async show(e,t){const i=[...f.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new ws(e.with({indexStatus:null}),e.indexStatus),new ws(e.with({workTreeStatus:null}))]:[new ws(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const s=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to ${Q.Space}$(git-branch) ${e.branch} status`},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),o=this.computeStatus(e.files);if(o.staged>0){let s=0;const a=o.unstaged>0?e.files.findIndex(e=>!e.staged):-1;a>-1&&(i.splice(a,0,new Gi({label:"Unstaged Files",description:o.unstagedStatus},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(a,0,new Cs(o.stagedAddsAndChanges,{label:`${Q.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new Cs(o.unstagedAddsAndChanges,{label:`${Q.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new Gi({label:"Staged Files",description:o.stagedStatus},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new Gi({label:"Unstaged Files",description:o.unstagedStatus},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new Cs(o.stagedAddsAndChanges.concat(o.unstagedAddsAndChanges))),i.push(new Gi({label:"$(x) Close Unchanged Files",description:""},Ut.CloseUnchangedFiles))):i.push(new Gi({label:"No changes in the working tree",description:""},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new Gi({label:"$(inbox) Show Stashed Changes",description:`${y.pad(Q.Dash,2,3)} shows stashed changes in the repository`},Ut.ShowQuickStashList,[Te.fromRepoPath(e.repoPath),{goBackCommand:s}])),e.upstream&&e.state.ahead&&i.splice(0,0,new Gi({label:`$(cloud-upload)${Q.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${Q.Space}$(git-branch) ${e.upstream}`,description:`${y.pad(Q.Dash,2,3)} shows commits in ${Q.Space}$(git-branch) ${e.branch} but not ${Q.Space}$(git-branch) ${e.upstream}`},Ut.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath,`${e.upstream}..${e.branch}`),{branch:e.branch,maxCount:0,goBackCommand:s}])),e.upstream&&e.state.behind&&i.splice(0,0,new Gi({label:`$(cloud-download)${Q.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${Q.Space}$(git-branch) ${e.upstream}`,description:`${y.pad(Q.Dash,2,3)} shows commits in ${Q.Space}$(git-branch) ${e.upstream} but not ${Q.Space}$(git-branch) ${e.branch}${e.sha?` (since ${Q.Space}$(git-commit) ${Lt.shortenSha(e.sha)})`:""}`},Ut.ShowQuickBranchHistory,[Te.fromRepoPath(e.repoPath,`${e.branch}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:s}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new Gi({label:`$(git-branch) ${e.branch} is up-to-date with ${Q.Space}$(git-branch) ${e.upstream}`,description:""},Ut.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const a=await Wo.keyboard.beginScope({left:t}),r=await L.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${y.pad(Q.ArrowLeftRight,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:Hi(),onDidSelectItem:e=>{a.setKeyCommand("right",e)}});return await a.dispose(),r}}class ys{static showProgress(e){return ji("apply"===e?`Apply stashed changes to your working tree${Q.Ellipsis}`:`stashed changes ${Q.Dash} search by message, filename, or commit id`,{left:Ai,",":Ai,".":Ai})}static async show(e,t,i,s,o){const a=e&&Array.from(f.map(e.commits.values(),e=>new qi(e)))||[];if("list"===t&&a.splice(0,0,new Gi({label:"$(plus) Stash Changes",description:`${y.pad(Q.Dash,2,3)} stashes all changes`},Ut.StashSave,[{goBackCommand:o}])),s&&a.splice(0,0,s),i.token.isCancellationRequested)return;const r=await Wo.keyboard.beginScope({left:s});i.cancel();const n=await L.window.showQuickPick(a,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${Q.Ellipsis}`:`stashed changes ${Q.Dash} search by message, filename, or commit id`,ignoreFocusOut:Hi()});return await r.dispose(),n}}class xs extends Si{constructor(){super([Ut.DiffHeadWithBranch,Ut.DiffWorkingWithBranch])}async preExecute(e,t={}){switch(e.command){case Ut.DiffHeadWithBranch:t.ref2="HEAD";break;case Ut.DiffWorkingWithBranch:t.ref2=""}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===i.ref2)return;let s;t=fi(t,e);try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to open branch compare");if(!i.ref1){let t;switch(i.ref2){case"":t=`Compare Working Tree to ${Q.Ellipsis}`;break;case"HEAD":t=`Compare Index (HEAD) to ${Q.Ellipsis}`;break;default:t=`Compare ${i.ref2} to ${Q.Ellipsis}`}s=Wi.showProgress(t);const[o,a]=await Promise.all([Wo.git.getBranches(e),Wo.git.getTags(e)]);if(s.token.isCancellationRequested)return;const r=await Wi.show(o,a,t,{progressCancellation:s});if(void 0===r)return;if(r instanceof Gi)return r.execute();if(i.ref1=r.name,void 0===i.ref1)return}return void Wo.resultsExplorer.showComparisonInResults(e,i.ref1,i.ref2)}catch(e){return ae.error(e,"DiffBranchWithBranchCommand"),L.window.showErrorMessage("Unable to open branch compare. See output channel for more details")}finally{s&&s.dispose()}}}class Ss extends Si{constructor(){super([Ut.DiffDirectory,Ut.ExternalDiffAll,Ut.ExplorersOpenDirectoryDiff,Ut.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case Ut.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case Ut.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof mi&&(t.ref1=e.node.ref1,t.ref2=e.node.ref2);break;case Ut.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof It})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let s;t=fi(t,e);try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to open directory compare");if(!i.ref1){i=Object.assign({},i);const t=`Compare Working Tree to ${Q.Ellipsis}`;s=Wi.showProgress(t);const[o,a]=await Promise.all([Wo.git.getBranches(e),Wo.git.getTags(e)]);if(s.token.isCancellationRequested)return;const r=await Wi.show(o,a,t,{progressCancellation:s});if(void 0===r)return;if(r instanceof Gi)return r.execute();if(i.ref1=r.name,void 0===i.ref1)return}return void Wo.git.openDirectoryDiff(e,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await L.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return L.commands.executeCommand(j.Open,L.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return ae.error(e,"DiffDirectoryCommand"),L.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{s&&s.dispose()}}}class $s extends Si{constructor(){super(Ut.DiffLineWithPrevious)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Lt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(s,t,e.document.getText()):await Wo.git.getBlameForLine(s,t);if(void 0===o)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await Wo.git.getStatusForFile(s.repoPath,s.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:Lt.stagedUncommittedSha}))}}catch(e){return ae.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),L.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Lt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,o)}}class Ds extends Si{constructor(){super(Ut.DiffLineWithWorking)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Lt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(s,t,e.document.getText()):await Wo.git.getBlameForLine(s,t);if(void 0===o)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=o.commit,i.commit.isUncommitted){const e=await Wo.git.getStatusForFile(s.repoPath,s.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?Lt.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=o.line.line+1}}catch(e){return ae.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),L.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,o)}}class ks extends Si{static getMarkdownCommandArgs(e,t){let i;if(e instanceof Ae){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:Lt.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(Ut.DiffWith,i)}constructor(){super(Ut.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{Lt.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await Wo.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),Lt.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await Wo.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[e,t]=await Promise.all([Wo.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),Wo.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let s="";void 0===t?s=Lt.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==e&&i.lhs.sha!==Lt.deletedSha||(s="added in ");let o="";if(void 0===e&&""===i.rhs.sha&&(void 0!==t?(o="not in ",s=""):o="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==Lt.deletedSha&&(void 0!==e||""!==o)){const e=Lt.shortenSha(i.lhs.sha)||"";i.lhs.title=`${Se.basename(i.lhs.uri.fsPath)}${""!==e?` (${o}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==Lt.deletedSha){const e=Lt.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${Se.basename(i.rhs.uri.fsPath)}${""!==e?` (${s}${e})`:s}`}const a=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${Q.ArrowLeftRight} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=L.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new L.Range(i.line,0,i.line,0)),await L.commands.executeCommand(j.Diff,void 0===e?Te.toRevisionUri(Lt.deletedSha,i.lhs.uri.fsPath,i.repoPath):L.Uri.file(e),void 0===t?Te.toRevisionUri(Lt.deletedSha,i.rhs.uri.fsPath,i.repoPath):L.Uri.file(t),a,i.showOptions)}catch(e){return ae.error(e,"DiffWithCommand","getVersionedFile"),L.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class Ps extends Si{constructor(){super(Ut.DiffWithBranch)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Te.fromUri(t);if(!s.repoPath)return Ti.showNoRepositoryWarningMessage("Unable to open file compare");const o=`Compare ${Se.basename(s.fsPath)} with ${Q.Ellipsis}`,a=Wi.showProgress(o);try{const[e,t]=await Promise.all([Wo.git.getBranches(s.repoPath),Wo.git.getTags(s.repoPath)]);if(a.token.isCancellationRequested)return;const r=await Wi.show(e,t,o,{progressCancellation:a,goBackCommand:i.goBackCommand});if(void 0===r)return;if(r instanceof Gi)return r.execute();const n=r.name;if(void 0===n)return;let h,c;const l=await Wo.git.getDiffStatus(s.repoPath,"HEAD",n,{filter:"R"});if(void 0!==l){const e=y.normalizePath(Se.relative(s.repoPath,s.fsPath)),t=l.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(h=L.Uri.file(Se.join(s.repoPath,t.originalFileName)),c=`${Se.basename(t.originalFileName)} (${n})`)}const d={repoPath:s.repoPath,lhs:{sha:r.remote?`remotes/${n}`:n,uri:h||s,title:c||`${Se.basename(s.fsPath)} (${n})`},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,d)}finally{a.dispose()}}}class Fs extends Si{constructor(){super(Ut.DiffWithNext)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Te.fromUri(t);let o;if(void 0===i.commit||!(i.commit instanceof je)||void 0!==i.range)try{const e=void 0===i.commit?s.sha:i.commit.sha;if(Lt.isStagedUncommitted(e))return L.commands.executeCommand(Ut.DiffWithWorking,t);const a=await Wo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:void 0!==e?void 0:2,range:i.range,renames:!0});if(void 0===a)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=e&&a.commits.get(e)||f.first(a.commits.values()),void 0===s.sha&&void 0!==(o=await Wo.git.getStatusForFile(s.repoPath,s.fsPath)))return L.commands.executeCommand(Ut.DiffWithWorking,t)}catch(e){return ae.error(e,"DiffWithNextCommand",`getLogForFile(${s.repoPath}, ${s.fsPath})`),L.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(o=o||await Wo.git.getStatusForFile(s.repoPath,s.fsPath))&&"M"===o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Lt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,e)}return L.commands.executeCommand(Ut.DiffWithWorking,t)}const a={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,a)}}class _s extends Si{constructor(){super(Ut.DiffWithPrevious)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await Te.fromUri(t);try{let s=void 0===i.commit?e.sha:i.commit.sha;if(s===Lt.deletedSha)return Ti.showCommitHasNoPreviousCommitWarningMessage();let o=!1;Lt.isStagedUncommitted(s)&&(e.sha=s=void 0,o=!0);const a=await Wo.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:s,renames:!0});if(void 0===a)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=s&&a.commits.get(s)||f.first(a.commits.values()),void 0===e.sha){const s=await Wo.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==s){if(o){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Lt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,e)}if(void 0!==s.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:Lt.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,e)}return L.commands.executeCommand(Ut.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return ae.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),L.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const s={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Lt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,s)}}class Rs extends Si{constructor(){super(Ut.DiffWithRevision)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);const s=await Te.fromUri(t),o=`Compare ${s.getFormattedPath()}${s.sha?` ${y.pad(Q.Dot,1,1)} ${s.shortSha}`:""} with ${Q.Ellipsis}`,a=ps.showProgress(o);try{const e=await Wo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,ref:s.sha});if(void 0===e)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(a.token.isCancellationRequested)return;let r=void 0;if(e.truncated){const s=new Gi({label:"$(arrow-right) Show Next Commits",description:`${y.pad(Q.Dash,2,3)} shows ${e.maxCount} newer commits`},Ut.DiffWithRevision,[t,Object.assign({},i)]),o=f.last(e.commits.values());null!=o&&(r=new Gi({label:"$(arrow-left) Show Previous Commits",description:`${y.pad(Q.Dash,2,3)} shows ${e.maxCount} older commits`},Ut.DiffWithRevision,[new Te(t,o),Object.assign({},i,{nextPageCommand:s})]))}const n=await ps.show(e,s,o,{pickerOnly:!0,progressCancellation:a,currentCommand:new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${s.getFormattedPath()}${s.sha?` from ${Q.Space}$(git-commit) ${s.shortSha}`:""}`},Ut.DiffWithRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:r,showAllCommand:void 0!==e&&e.truncated?new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===n)return;let h;if(n instanceof Zi){const e=await n.execute();if(void 0===e)return;if(e instanceof Gi)return e.execute();h=e.name}else{if(n instanceof Gi)return n.execute();h=n.commit.sha}const c={repoPath:s.repoPath,lhs:{sha:h,uri:s},rhs:{sha:"",uri:s},line:i.line,showOptions:i.showOptions};return await L.commands.executeCommand(Ut.DiffWith,c)}catch(e){return ae.error(e,"DiffWithRevisionCommand"),L.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{a.dispose()}}}class Ts extends Si{constructor(){super(Ut.DiffWithWorking)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line),void 0===i.commit||Lt.isUncommitted(i.commit.sha)){if(void 0===s.sha)return L.window.showInformationMessage("File matches the working tree");if(Lt.isStagedUncommitted(s.sha)){s.sha=void 0;const e=await Wo.git.getStatusForFile(s.repoPath,s.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:s.repoPath,lhs:{sha:Lt.stagedUncommittedSha,uri:s.fileUri()},rhs:{sha:"",uri:s.fileUri()},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,e)}}try{if(i.commit=await Wo.git.getLogCommitForFile(s.repoPath,s.fsPath,{ref:s.sha,firstIfNotFound:!0}),void 0===i.commit)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return ae.error(e,"DiffWithWorkingCommand",`getLogCommit(${s.repoPath}, ${s.fsPath}, ${s.sha})`),L.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[o]=await Wo.git.findWorkingFileName(s.fsPath,s.repoPath);if(void 0===o)return;const a={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return L.commands.executeCommand(Ut.DiffWith,a)}}var Es,Bs;!function(e){e[e.INDEX_MODIFIED=0]="INDEX_MODIFIED",e[e.INDEX_ADDED=1]="INDEX_ADDED",e[e.INDEX_DELETED=2]="INDEX_DELETED",e[e.INDEX_RENAMED=3]="INDEX_RENAMED",e[e.INDEX_COPIED=4]="INDEX_COPIED",e[e.MODIFIED=5]="MODIFIED",e[e.DELETED=6]="DELETED",e[e.UNTRACKED=7]="UNTRACKED",e[e.IGNORED=8]="IGNORED",e[e.ADDED_BY_US=9]="ADDED_BY_US",e[e.ADDED_BY_THEM=10]="ADDED_BY_THEM",e[e.DELETED_BY_US=11]="DELETED_BY_US",e[e.DELETED_BY_THEM=12]="DELETED_BY_THEM",e[e.BOTH_ADDED=13]="BOTH_ADDED",e[e.BOTH_DELETED=14]="BOTH_DELETED",e[e.BOTH_MODIFIED=15]="BOTH_MODIFIED"}(Es||(Es={})),function(e){e[e.Merge=0]="Merge",e[e.Index=1]="Index",e[e.WorkingTree=2]="WorkingTree"}(Bs||(Bs={}));class Ns{constructor(e,t){this.uri=e,this.staged=t}}class As extends xi{constructor(){super(Ut.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new Ns(e.resourceUri,e.resourceGroupType===Bs.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=o.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new Ns(e.resourceUri,e.resourceGroupType===Bs.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===Es.BOTH_MODIFIED||t===Es.INDEX_MODIFIED||t===Es.MODIFIED}async execute(e={}){try{const t=await Wo.git.getRepoPath(void 0);if(!t)return Ti.showNoRepositoryWarningMessage("Unable to open external file compare");const i=await Wo.git.getDiffTool(t);if(void 0===i){if(!await L.window.showWarningMessage("Unable to open external file compare because there is no Git diff tool configured","View Git Docs"))return;return L.commands.executeCommand(j.Open,L.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await Wo.git.getStatusForRepo(t);if(void 0===i)return L.window.showWarningMessage("Unable to open external file compare");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new Ns(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new Ns(t.uri,!1))}for(const s of e.files)Wo.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return ae.error(e,"ExternalDiffCommand"),L.window.showErrorMessage("Unable to open external file compare. See output channel for more details")}}}class Us extends Si{constructor(){super(Ut.OpenChangedFiles)}async execute(e,t,i={}){t=fi(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to open changed files");const s=await Wo.git.getStatusForRepo(e);if(void 0===s)return L.window.showWarningMessage("Unable to open changed files");i.uris=o.filterMap(s.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await Pi(e,{preserveFocus:!0,preview:!1});return}catch(e){return ae.error(e,"OpenChangedFilesCommand"),L.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class Ls extends Si{constructor(){super(Ut.OpenBranchesInRemote)}async preExecute(e,t={}){return Ci(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=fi(t,e))&&await Te.fromUri(t),o=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(o)try{const e=(await Wo.git.getRemotes(o)).filter(e=>void 0!==e.provider);return L.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:e})}catch(e){return ae.error(e,"OpenBranchesInRemoteCommand"),L.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class Os extends Si{constructor(){super(Ut.OpenBranchInRemote)}async preExecute(e,t={}){return vi(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=fi(t,e))&&await Te.fromUri(t),o=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(o)try{if(void 0===i.branch){i=Object.assign({},i);const e=await Wo.git.getBranches(o),t=await ts.show(e,`Show history for branch${Q.Ellipsis}`);if(void 0===t)return;if(t instanceof Gi)return;if(i.branch=t.branch.name,void 0===i.branch)return}const e=(await Wo.git.getRemotes(o)).filter(e=>void 0!==e.provider);return L.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:"branch",branch:i.branch},remote:i.remote,remotes:e})}catch(e){return ae.error(e,"OpenBranchInRemoteCommandArgs"),L.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class Is extends Si{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Ut.OpenCommitInRemote,t)}constructor(){super(Ut.OpenCommitInRemote)}async preExecute(e,t={}){return wi(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(s.repoPath)try{if(void 0===i.sha){const t=void 0===e?0:e.selection.active.line;if(t<0)return;const o=e&&e.document&&e.document.isDirty?await Wo.git.getBlameForLineContents(s,t,e.document.getText()):await Wo.git.getBlameForLine(s,t);if(void 0===o)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let a=o.commit;a.isUncommitted&&(a=a.with({sha:a.previousSha,fileName:a.previousFileName,previousSha:null,previousFileName:null})),i.sha=a.sha}const o=(await Wo.git.getRemotes(s.repoPath)).filter(e=>void 0!==e.provider);return L.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:o})}catch(e){return ae.error(e,"OpenCommitInRemoteCommand"),L.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class Ms extends Si{constructor(){super(Ut.OpenFileInRemote)}async preExecute(e,t={range:!0}){return wi(e)?((t=Object.assign({},t)).range=!1,vi(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);if(s.repoPath){if(void 0===i.branch){const e=await Wo.git.getBranch(s.repoPath);void 0!==e&&(i.branch=e.name)}try{const o=(await Wo.git.getRemotes(s.repoPath)).filter(e=>void 0!==e.provider),a=i.range&&void 0!==e?new L.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return L.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:void 0===s.sha?"file":"revision",branch:i.branch,fileName:s.getRelativePath(),range:a,sha:s.sha},remotes:o})}catch(e){return ae.error(e,"OpenFileInRemoteCommand"),L.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class Ws extends Si{static getMarkdownCommandArgs(e,t,i){let s;if(e instanceof L.Uri){s={uri:e,line:i,annotationType:t}}else s=e;return super.getMarkdownCommandArgsCore(Ut.OpenFileRevision,s)}constructor(){super(Ut.OpenFileRevision)}async execute(e,t,i={}){let s;void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=fi(t,e)))return;const o=await Te.fromUri(t),a=`Open ${o.getFormattedPath()}${o.sha?` ${y.pad(Q.Dot,1,1)} ${o.shortSha}`:""} in revision ${Q.Ellipsis}`;s=ps.showProgress(a);const r=await Wo.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:o.sha});if(void 0===r)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(s.token.isCancellationRequested)return;let n=void 0;if(r.truncated){const e=new Gi({label:"$(arrow-right) Show Next Commits",description:`${y.pad(Q.Dash,2,3)} shows ${r.maxCount} newer commits`},Ut.OpenFileRevision,[t,Object.assign({},i)]),s=f.last(r.commits.values());null!=s&&(n=new Gi({label:"$(arrow-left) Show Previous Commits",description:`${y.pad(Q.Dash,2,3)} shows ${r.maxCount} older commits`},Ut.OpenFileRevision,[new Te(t,s),Object.assign({},i,{nextPageCommand:e})]))}const h=await ps.show(r,o,a,{pickerOnly:!0,progressCancellation:s,currentCommand:new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${o.getFormattedPath()}${o.sha?` from ${Q.Space}$(git-commit) ${o.shortSha}`:""}`},Ut.OpenFileRevision,[t,Object.assign({},i)]),nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==r&&r.truncated?new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof Zi){const e=await h.execute();if(void 0===e)return;if(e instanceof Gi)return e.execute();i.uri=Te.toRevisionUri(e.name,o.fsPath,o.repoPath)}else{if(h instanceof Gi)return h.execute();i.uri=Te.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new L.Range(i.line,0,i.line,0));const o=await Pi(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:Wo.annotations.showAnnotations(o,i.annotationType,i.line)}catch(e){return ae.error(e,"OpenFileRevisionCommand"),L.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{s&&s.dispose()}}}class Hs extends Si{constructor(){super(Ut.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length){return this.ensureRemoteBranchName(i),new is(i.remotes[0],i.resource).execute()}let e="";switch(i.resource.type){case de.Branch:this.ensureRemoteBranchName(i),e=`open ${i.resource.branch} branch in${Q.Ellipsis}`;break;case de.Commit:e=`open commit ${Lt.shortenSha(i.resource.sha)} in${Q.Ellipsis}`;break;case de.File:e=`open ${i.resource.fileName} in${Q.Ellipsis}`;break;case de.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof je)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,e=`open ${i.resource.fileName} ${y.pad(Q.Dot,1,1)} ${i.resource.commit.previousShortSha} in${Q.Ellipsis}`):(i.resource.sha=i.resource.commit.sha,e=`open ${i.resource.fileName} ${y.pad(Q.Dot,1,1)} ${i.resource.commit.shortSha} in${Q.Ellipsis}`);else{const t=void 0===i.resource.sha?"":Lt.shortenSha(i.resource.sha),s=t?` ${y.pad(Q.Dot,1,1)} ${t}`:"";e=`open ${i.resource.fileName}${s} in${Q.Ellipsis}`}}if(1===i.remotes.length){return new is(i.remotes[0],i.resource).execute()}const t=await os.show(i.remotes,e,i.resource,i.goBackCommand);if(void 0===t)return;return t.execute()}catch(e){return ae.error(e,"OpenInRemoteCommand"),L.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class js extends Si{constructor(){super(Ut.OpenRepoInRemote)}async preExecute(e,t={}){return Ci(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const s=(t=fi(t,e))&&await Te.fromUri(t),o=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(o)try{const e=(await Wo.git.getRemotes(o)).filter(e=>void 0!==e.provider);return L.commands.executeCommand(Ut.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:e})}catch(e){return ae.error(e,"OpenRepoInRemoteCommand"),L.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class Gs extends Si{constructor(){super(Ut.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=void 0===e?0:e.selection.active.line);try{if(void 0===i.uri){if(void 0===(t=fi(t,e)))return;if(i.uri=await Te.fromUri(t),i.uri instanceof Te&&i.uri.sha){const[e,t]=await Wo.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new Te(L.Uri.file(Se.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new L.Range(i.line,0,i.line,0));const s=await Pi(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?s:Wo.annotations.showAnnotations(s,i.annotationType,i.line)}catch(e){return ae.error(e,"OpenWorkingFileCommand"),L.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class Vs extends xi{constructor(){super(Ut.ResetSuppressedWarnings)}async execute(){await Go.update(Go.name("advanced")("messages").value,void 0,L.ConfigurationTarget.Global)}}const Qs=/^([@~=:#])/,Ks=new Map([["@",Et.Author],["~",Et.Changes],["=",Et.ChangedOccurrences],[":",Et.Files],["#",Et.Sha]]);class zs extends Di{constructor(){super(Ut.ShowCommitSearch)}async execute(e,t,i={}){const s=void 0===(t=fi(t,e))?void 0:await Te.fromUri(t);let o=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(!o){const e=await vs.show(`Search for commits in which repository${Q.Ellipsis}`,i.goBackCommand);if(e instanceof Gi)return e.execute();if(void 0===e)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();o=e.repoPath}i=Object.assign({},i);const a=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&void 0!==e&&void 0!==s){const t=await Wo.git.getBlameForLine(s,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){ae.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await L.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (~<pattern>), or changed occurrences (=<string>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();a.search=i.search;const t=Qs.exec(i.search);t&&t[1]?(i.searchBy=Ks.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):Lt.isSha(i.search)?i.searchBy=Et.Sha:i.searchBy=Et.Message}void 0===i.searchBy&&(i.searchBy=Et.Message);let r=void 0;switch(i.searchBy){case Et.Author:r=`commits with an author matching '${i.search}'`;break;case Et.Changes:r=`commits with changes matching '${i.search}'`;break;case Et.ChangedOccurrences:r=`commits with changed occurrences matching '${i.search}'`;break;case Et.Files:r=`commits with files matching '${i.search}'`;break;case Et.Message:r=`commits with a message matching '${i.search}'`;break;case Et.Sha:r=`commits with an id matching '${i.search}'`}const n=us.showProgress(r);try{const e=await Wo.git.getLogForSearch(o,i.search,i.searchBy,{maxCount:i.maxCount});if(n.token.isCancellationRequested)return;const s=i.goBackCommand||new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to commit search`},Ut.ShowCommitSearch,[t,a]),h=await us.show(e,r,n,{goBackCommand:s,showAllCommand:void 0!==e&&e.truncated?new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:s})]):void 0,showInResultsExplorerCommand:void 0!==e?new Ji(e,r):void 0});if(void 0===h)return;return h instanceof Gi?h.execute():L.commands.executeCommand(Ut.ShowQuickCommitDetails,h.commit.toGitUri(),{sha:h.commit.sha,commit:h.commit,goBackCommand:new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,2)} to search for ${r}`},Ut.ShowCommitSearch,[t,i])})}catch(e){return ae.error(e,"ShowCommitSearchCommand"),L.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{n.dispose()}}}class qs extends ki{constructor(){super(Ut.ShowFileBlame)}async execute(e,t,i,s={}){if(void 0!==e)try{return void 0===s.type&&(s=Object.assign({},s,{type:R.Blame})),Wo.annotations.showAnnotations(e,s.type,void 0!==s.sha?s.sha:e.selection.active.line)}catch(e){return ae.error(e,"ShowFileBlameCommand"),L.window.showErrorMessage("Unable to show file blame annotations. See output channel for more details")}}}class Ys extends xi{constructor(){super(Ut.ShowLastQuickPick)}async execute(){const e=$i;if(void 0!==e)try{return L.commands.executeCommand(e.command,...e.args)}catch(e){return ae.error(e,"ShowLastQuickPickCommand"),L.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class Xs extends Si{constructor(){super(Ut.ShowLineBlame)}async execute(e,t){try{return Wo.lineAnnotations.showAnnotations(e)}catch(e){return ae.error(e,"ShowLineBlameCommand"),L.window.showErrorMessage("Unable to show line blame annotations. See output channel for more details")}}}class Js extends Di{constructor(){super(Ut.ShowQuickBranchHistory)}async execute(e,t,i={}){const s=(t=fi(t,e))&&await Te.fromUri(t);let o=void 0===(i=Object.assign({},i)).branch?void 0:gs.showProgress(i.branch);try{const e=void 0===s?Wo.git.getHighlanderRepoPath():s.repoPath;if(!e)return Ti.showNoRepositoryWarningMessage("Unable to show branch history");if(void 0===i.branch){const t=await Wo.git.getBranches(e),s=await ts.show(t,`Show history for branch${Q.Ellipsis}`);if(void 0===s)return;if(s instanceof Gi)return s.execute();if(i.branch=s.branch.name,void 0===i.branch)return;o=gs.showProgress(i.branch)}if(void 0===i.log&&(i.log=await Wo.git.getLog(e,{maxCount:i.maxCount,ref:s&&s.sha||i.branch}),void 0===i.log))return L.window.showWarningMessage("Unable to show branch history");if(void 0!==o&&o.token.isCancellationRequested)return;const a=await gs.show(i.log,s,i.branch,o,i.goBackCommand,i.nextPageCommand);if(void 0===a)return;if(a instanceof Gi)return a.execute();const r=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to ${Q.Space}$(git-branch) ${i.branch} history`},Ut.ShowQuickBranchHistory,[t,Object.assign({},i)]);return L.commands.executeCommand(Ut.ShowQuickCommitDetails,a.commit.toGitUri(),{sha:a.commit.sha,commit:a.commit,repoLog:i.log,goBackCommand:r})}catch(e){return ae.error(e,"ShowQuickBranchHistoryCommand"),L.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{o&&o.dispose()}}}class Zs extends Di{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Ut.ShowQuickCommitDetails,t)}constructor(){super(Ut.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,wi(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;const s=await Te.fromUri(t);let o=s.repoPath,a=Se.relative(o||"",s.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const e=await Wo.git.getBlameForLine(s,t);if(void 0===e)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(e.commit.isUncommitted)return Ti.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=e.commit.sha,o=e.commit.repoPath,a=e.commit.fileName,i.commit=e.commit}catch(e){return ae.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),L.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await Wo.git.getLog(o,{maxCount:2,ref:i.sha});if(void 0===e)return Ti.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return Ti.showCommitNotFoundWarningMessage("Unable to show commit details");void 0===i.commit.workingFileName&&(i.commit.workingFileName=a),void 0===i.goBackCommand&&(i.goBackCommand=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to branch history`},Ut.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]));const e=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to details of ${Q.Space}$(git-commit) ${i.commit.shortSha}`},Ut.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),s=await hs.show(i.commit,t,i.goBackCommand,e,i.repoLog);if(void 0===s)return;return s instanceof as?L.commands.executeCommand(Ut.ShowQuickCommitFileDetails,s.commit.toGitUri(),{commit:s.commit,sha:s.sha,goBackCommand:e}):s.execute()}catch(e){return ae.error(e,"ShowQuickCommitDetailsCommand"),L.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class eo extends Di{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(Ut.ShowQuickCommitFileDetails,t)}constructor(){super(Ut.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,wi(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return;let s=i.commit&&i.commit.workingFileName;const o=await Te.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(void 0===e)return;const t=e.selection.active.line;if(t<0)return;try{const e=await Wo.git.getBlameForLine(o,t);if(void 0===e)return Ti.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(e.commit.isUncommitted)return Ti.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=e.commit.sha,i.commit=e.commit,s=Se.relative(i.commit.repoPath,o.fsPath)}catch(e){return ae.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),L.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(s=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await Wo.git.getLogCommitForFile(void 0===i.commit?o.repoPath:i.commit.repoPath,o.fsPath,{ref:i.sha}),void 0===i.commit)))return Ti.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return Ti.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=s,[i.commit.workingFileName]=await Wo.git.findWorkingFileName(i.commit);const e=Lt.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to details of ${Q.Space}$(git-commit) ${e}`},Ut.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const a=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to details of ${Q.Space}$(file-text) ${Se.basename(i.commit.fileName)} in ${Q.Space}$(git-commit) ${e}`},Ut.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),r=await ms.show(i.commit,t,i.goBackCommand,a,i.fileLog);if(void 0===r)return;return r instanceof Gi?r.execute():void 0}catch(e){return ae.error(e,"ShowQuickCommitFileDetailsCommand"),L.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class to extends Di{constructor(){super(Ut.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=fi(t,e);try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to show branch history");const s=await Wo.git.getBranch(e);if(void 0===s)return;return L.commands.executeCommand(Ut.ShowQuickBranchHistory,t,{branch:s.name,goBackCommand:i.goBackCommand})}catch(e){return ae.error(e,"ShowQuickCurrentBranchHistoryCommand"),L.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class io extends Di{constructor(){super(Ut.ShowQuickFileHistory)}async execute(e,t,i={}){if(void 0===(t=fi(t,e)))return L.commands.executeCommand(Ut.ShowQuickCurrentBranchHistory);const s=await Te.fromUri(t);i=Object.assign({},i);const o=`${s.getFormattedPath()}${s.sha?` ${y.pad(Q.Dot,1,1)} ${s.shortSha}`:""}`,a=ps.showProgress(o);try{if(void 0===i.log&&(i.log=await Wo.git.getLogForFile(s.repoPath,s.fsPath,{maxCount:i.maxCount,range:i.range,ref:s.sha}),void 0===i.log))return Ti.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(a.token.isCancellationRequested)return;let e=void 0;if(i.log.truncated){const o=new Gi({label:"$(arrow-right) Show Next Commits",description:`${y.pad(Q.Dash,2,3)} shows ${i.log.maxCount} newer commits`},Ut.ShowQuickFileHistory,[s,Object.assign({},i,{log:void 0})]),a=f.last(i.log.commits.values());null!=a&&(e=new Gi({label:"$(arrow-left) Show Previous Commits",description:`${y.pad(Q.Dash,2,3)} shows ${i.log.maxCount} older commits`},Ut.ShowQuickFileHistory,[new Te(t,a),Object.assign({},i,{log:void 0,nextPageCommand:o})]))}const r=await ps.show(i.log,s,o,{progressCancellation:a,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:e,showAllCommand:void 0!==i.log&&i.log.truncated?new Gi({label:"$(sync) Show All Commits",description:`${y.pad(Q.Dash,2,3)} this may take a while`},Ut.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new Xi(i.log,{label:o,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===r)return;if(r instanceof Gi)return r.execute();const n=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to history of ${Q.Space}$(file-text) ${Se.basename(r.commit.fileName)}${s.sha?` from ${Q.Space}$(git-commit) ${s.shortSha}`:""}`},Ut.ShowQuickFileHistory,[t,i]);return L.commands.executeCommand(Ut.ShowQuickCommitFileDetails,r.commit.toGitUri(),{commit:r.commit,fileLog:i.log,sha:r.commit.sha,goBackCommand:n})}catch(e){return ae.error(e,"ShowQuickFileHistoryCommand"),L.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{a.dispose()}}}class so extends Di{constructor(){super(Ut.ShowQuickRepoStatus)}async execute(e,t,i={}){t=fi(t,e);try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to show repository status");const s=await Wo.git.getStatusForRepo(e);if(void 0===s)return L.window.showWarningMessage("Unable to show repository status");const o=await bs.show(s,i.goBackCommand);if(void 0===o)return;return o instanceof Gi?o.execute():void 0}catch(e){return ae.error(e,"ShowQuickRepoStatusCommand"),L.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class oo extends Di{constructor(){super(Ut.ShowQuickStashList)}async execute(e,t,i={}){t=fi(t,e);const s=ys.showProgress("list");try{const e=await Wo.git.getRepoPath(t);if(!e)return Ti.showNoRepositoryWarningMessage("Unable to show stashed changes");const o=await Wo.git.getStashList(e);if(void 0===o)return L.window.showWarningMessage("Unable to show stashed changes");if(s.token.isCancellationRequested)return;const a=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to stashed changes`},Ut.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),r=await ys.show(o,"list",s,i.goBackCommand,a);if(void 0===r)return;return r instanceof Gi?r.execute():L.commands.executeCommand(Ut.ShowQuickCommitDetails,r.commit.toGitUri(),{commit:r.commit,sha:r.commit.sha,goBackCommand:a})}catch(e){return ae.error(e,"ShowQuickStashListCommand"),L.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{s.dispose()}}}class ao extends xi{constructor(){super(Ut.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return wi(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await Wo.git.getActiveRepoPath();if(!i){const s=await vs.show(`Apply stashed changes from which repository${Q.Ellipsis}`,e.goBackCommand);if(s instanceof Gi)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to pick another repository`},Ut.StashApply,[e]),i=s.repoPath}const s=ys.showProgress("apply");try{const o=await Wo.git.getStashList(i);if(void 0===o)return L.window.showInformationMessage("There are no stashed changes");if(s.token.isCancellationRequested)return;const a=new Gi({label:`go back ${Q.ArrowBack}`,description:`${y.pad(Q.Dash,2,3)} to apply stashed changes`},Ut.StashApply,[e]),r=await ys.show(o,"apply",s,t||e.goBackCommand,a);if(r instanceof Gi)return r.execute();if(void 0===r)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=a,e.stashItem=r.commit}finally{s.dispose()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${Q.Ellipsis}`:e.stashItem.message,i=await L.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await Wo.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return ae.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?L.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?L.window.showInformationMessage("Stash applied with conflicts"):L.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class ro extends xi{constructor(){super(Ut.StashDelete)}async preExecute(e,t={confirm:!0}){return wi(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${Q.Ellipsis}`:e.stashItem.message,i=await L.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await Wo.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return ae.error(e,"StashDeleteCommand"),L.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class no extends xi{constructor(){super(Ut.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await Wo.git.getHighlanderRepoPath();if(!t){const i=await vs.show(`Stash changes for which repository${Q.Ellipsis}`,e.goBackCommand);if(i instanceof Gi)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await L.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await Wo.git.stashSave(t,e.message,e.uris)}catch(e){return ae.error(e,"StashSaveCommand"),L.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class ho extends xi{constructor(){super(Ut.ToggleCodeLens)}execute(){return Wo.codeLens.toggleCodeLens()}}class co extends ki{constructor(){super(Ut.ToggleFileBlame)}async execute(e,t,i,s={}){if(void 0!==e){if(void 0!==i&&!te.equals(i,e.document.uri)){const t=L.window.visibleTextEditors.find(e=>te.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return void 0===s.type&&(s=Object.assign({},s,{type:R.Blame})),Wo.annotations.toggleAnnotations(e,s.type,void 0!==s.sha?s.sha:e.selection.active.line)}catch(e){return ae.error(e,"ToggleFileBlameCommand"),L.window.showErrorMessage(`Unable to toggle file ${s.type} annotations. See output channel for more details`)}}}}class lo extends ki{constructor(){super(Ut.ToggleFileHeatmap)}async execute(e,t,i){L.commands.executeCommand(Ut.ToggleFileBlame,i,{type:R.Heatmap})}}class mo extends ki{constructor(){super(Ut.ToggleFileRecentChanges)}async execute(e,t,i){L.commands.executeCommand(Ut.ToggleFileBlame,i,{type:R.RecentChanges})}}class uo extends Si{constructor(){super(Ut.ToggleLineBlame)}async execute(e,t){try{return Wo.lineAnnotations.toggleAnnotations(e)}catch(e){return ae.error(e,"ToggleLineBlameCommand"),L.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}const go=/[`\>\#\*\_\-\+\.]/g;class po{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(i,t);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=d.dateDaysFromNow(t,e);return i<=2?"#ffeca7":i<=7?"#ffdd8c":i<=14?"#ffdd7c":i<=30?"#fba447":i<=60?"#f68736":i<=90?"#f37636":i<=180?"#ca6632":i<=365?"#c0513f":i<=730?"#a2503a":"#793738"}static getHoverCommandBar(e,t,i){let s=`[\`${Q.DoubleArrowLeft}\`](${ks.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===R.RecentChanges&&(i=R.Blame);const t=Te.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath),o=L.window.activeTextEditor.selection.active.line;s+=`[\`${Q.SquareWithTopShadow}\`](${Ws.getMarkdownCommandArgs(t,i||R.Blame,o)} "Blame Previous Revision") `}return t&&(s+=`[\`${Q.ArrowUpRight}\`](${Is.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),s+=`[\`${Q.MiddleEllipsis}\`](${eo.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,s){null===t&&(t="MMMM Do, YYYY h:mma");let o="",a="",r="";e.isUncommitted?r=`\`${e.shortSha||"00000000"}\``:(a=`\n\n${this.getHoverCommandBar(e,i,s)}`,r=`[\`${e.shortSha}\`](${Zs.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,o=`\n\n> ${o=e.message.replace(go,"\\$&").replace(/^===/gm,`${Q.ZeroWidthSpace}===`).replace(/\n/g,"  \n")}`);const n=new L.MarkdownString(`${r} &nbsp; ![](${e.getGravatarUri(Wo.config.defaultGravatarsStyle).toString()}) &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${o}${a}`);return n.isTrusted=!0,n}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const s=this.getCodeDiff(i);let o;o=e.isUncommitted?void 0!==t.sha&&Lt.isStagedUncommitted(t.sha)?`[\`Changes\`](${ks.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${Q.Dash} &nbsp; [\`${e.previousShortSha}\`](${Zs.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${Q.ArrowLeftRight} _${t.shortSha}_\n${s}`:`[\`Changes\`](${ks.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${Q.Dash} &nbsp; _uncommitted_\n${s}`:`[\`Changes\`](${ks.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${Q.Dash} &nbsp; [\`${e.previousShortSha}\`](${Zs.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${Q.ArrowLeftRight} [\`${e.shortSha}\`](${Zs.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${s}`;const a=new L.MarkdownString(o);return a.isTrusted=!0,a}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&Lt.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await Wo.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static detailsHover(e,t,i,s){return{hoverMessage:this.getHoverMessage(e,t,i,s)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const a=Rt.fromTemplate(t,e,i);return o.renderOptions.before.contentText=y.pad(a.replace(/ /g,Q.Space),1,1),o}static gutterRenderOptions(e,t,i,o){let a=0;for(const e of s.values(o.tokenOptions))if(void 0!==e){if(null==e.truncateTo){a=-1;break}a+=e.truncateTo}a>=0&&(a+=y.width(y.interpolate(i,void 0)))>0&&(a+=3);let r=void 0,n=void 0;return t.enabled&&(r="solid",n="left"===t.location?"0 0 0 2px":"0 2px 0 0"),{backgroundColor:new L.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:r,borderWidth:n,color:new L.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:a>=0?`${a}ch`:void 0,uncommittedColor:new L.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return po.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:Q.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static hover(e,t,i){const s={renderOptions:{before:Object.assign({},t)}};return this.applyHeatmap(s,e.date,i),s}static hoverRenderOptions(e){return e.enabled?{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:Q.ZeroWidthSpace,height:"100%",margin:"0 26px 0 0",textDecoration:"none"}:{before:void 0}}static trailing(e,t,i){const s=Rt.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new L.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new L.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:y.pad(s.replace(/ /g,Q.Space),1,1),fontWeight:"normal",fontStyle:"normal"}}}}static withRange(e,t,i){let s=e.range;return void 0!==t&&(s=s.with({start:s.start.with({character:t})})),void 0!==i&&(s=s.with({end:s.end.with({character:i})})),Object.assign({},e,{range:s})}}class fo extends se{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?Wo.git.getBlameForFileContents(this._uri,e.document.getText()):Wo.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}async clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){void 0!==this.editor&&(this._blame=this.editor.document.isDirty?Wo.git.getBlameForFileContents(this._uri,this.editor.document.getText()):Wo.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=f.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const s=o.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new L.Range(e.line,0,e.line,H)):void 0);this.editor.setDecorations(this.highlightDecoration,s)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}registerHoverProviders(e){if(!Wo.config.hovers.enabled||!Wo.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(L.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(L.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=L.Disposable.from(...t)}async provideDetailsHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;let o=void 0;s.isUncommitted||void 0!==(o=await Wo.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(o.previousFileName=s.previousFileName,o.previousSha=s.previousSha);const a=po.getHoverMessage(o||s,Wo.config.defaultDateFormat,await Wo.git.hasRemote(s.repoPath),this.annotationType);return new L.Hover(a,e.validateRange(new L.Range(t.line,0,t.line,H)))}async provideChangesHover(e,t,i){const s=await this.getCommitForHover(t);if(void 0===s)return;const o=await po.changesHover(s,t.line,await Te.fromUri(e.uri));return new L.Hover(o.hoverMessage,e.validateRange(new L.Range(t.line,0,t.line,H)))}async getCommitForHover(e){if("line"!==Wo.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class vo extends fo{async onProvideAnnotation(e,t){this.annotationType=R.Blame;const i=await this.getBlame();if(void 0===i)return!1;const o=process.hrtime(),a=Wo.config.blame,r=y.getTokensFromTemplate(a.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),n={dateFormat:null===a.dateFormat?Wo.config.defaultDateFormat:a.dateFormat,tokenOptions:r},h=Date.now(),c=a.avatars,l=Wo.config.defaultGravatarsStyle,d=a.separateLines,m=po.gutterRenderOptions(d,a.heatmap,a.format,n);this.decorations=[];const u=Object.create(null),g=c?Object.create(null):void 0;let p,f,v,w=!1;for(const e of i.lines){const t=e.line;v!==e.sha?(w=!1,v=e.sha,void 0!==(p=i.commits.get(e.sha))&&(void 0===(f=u[e.sha])?(f=po.gutter(p,a.format,n,m),a.heatmap.enabled&&po.applyHeatmap(f,p.date,h),f.range=new L.Range(t,0,t,0),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g),u[e.sha]=f):(f=Object.assign({},f,{range:new L.Range(t,0,t,0)}),this.decorations.push(f),c&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g)))):(f=Object.assign({},f),a.compact&&!w&&(f.renderOptions={before:Object.assign({},f.renderOptions.before,{contentText:Q.Space.repeat(y.width(f.renderOptions.before.contentText))})},d&&(f.renderOptions.before.textDecoration="none"),w=!0),f.range=new L.Range(t,0,t,0),this.decorations.push(f),c&&!a.compact&&void 0!==p&&void 0!==p.email&&this.addOrUpdateGravatarDecoration(p,f.range,l,g))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),c)){this.additionalDecorations=[];for(const e of s.values(g))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const C=process.hrtime(o);return ae.log(`${1e3*C[0]+Math.floor(C[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(Wo.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,s){const o=s[e.email];void 0===o?s[e.email]={decoration:L.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:o.ranges.push(t)}}class wo extends fo{async onProvideAnnotation(e,t){this.annotationType=R.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const s=process.hrtime(),o=Date.now(),a=po.heatmapRenderOptions();this.decorations=[];const r=Object.create(null);let n,h;for(const e of i.lines){const t=e.line;void 0===(h=r[e.sha])?void 0!==(n=i.commits.get(e.sha))&&((h=po.heatmap(n,o,a)).range=new L.Range(t,0,t,0),this.decorations.push(h),r[e.sha]=h):(h=Object.assign({},h,{range:new L.Range(t,0,t,0)}),this.decorations.push(h))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const c=process.hrtime(s);return ae.log(`${1e3*c[0]+Math.floor(c[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(Wo.config.hovers.annotations),this.selection(e,i),!0}}class Co extends se{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=R.RecentChanges;const t=await Wo.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await Wo.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const s=process.hrtime(),o=Wo.config,a=o.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const s of e.lines){if(void 0===s.line)continue;if(i++,"unchanged"===s.state)continue;const e=this.editor.document.validateRange(new L.Range(new L.Position(i,0),new L.Position(i,H)));let r=void 0;o.hovers.enabled&&o.hovers.annotations.enabled&&(o.hovers.annotations.details&&this.decorations.push({hoverMessage:po.getHoverMessage(t,a,await Wo.git.hasRemote(t.repoPath),this.annotationType),range:e}),o.hovers.annotations.changes&&(r=po.getHoverDiffMessage(t,this._uri,s))),this.decorations.push({hoverMessage:r,range:e})}}this.editor.setDecorations(this.highlightDecoration,this.decorations);const r=process.hrtime(s);return ae.log(`${1e3*r[0]+Math.floor(r[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var bo;!function(e){e.User="User",e.BlameabilityChanged="BlameabilityChanged",e.ColumnChanged="ColumnChanged",e.Disposing="Disposing",e.DocumentChanged="DocumentChanged",e.DocumentClosed="DocumentClosed"}(bo||(bo={}));const yo={blameAnnotation:L.window.createTextEditorDecorationType({isWholeLine:!0,rangeBehavior:L.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class xo extends L.Disposable{constructor(){super(()=>this.dispose()),this._onDidToggleAnnotations=new L.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._disposable=L.Disposable.from(Go.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(Go.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this._annotationProviders.forEach(async(e,t)=>await this.clearCore(t,bo.Disposing)),yo.blameAnnotation&&yo.blameAnnotation.dispose(),yo.blameHighlight&&yo.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=Go.initializing(e),i=Wo.config;if(t||Go.changed(e,Go.name("blame")("highlight").value)){yo.blameHighlight&&yo.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?yo.blameHighlight=L.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:L.OverviewRulerLane.Right,backgroundColor:e.locations.includes(B.Line)?new L.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(B.Overview)?new L.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(B.Gutter)?Wo.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(B.Gutter)?Wo.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):yo.blameHighlight=void 0}if(t||Go.changed(e,Go.name("recentChanges")("highlight").value)){yo.recentChangesHighlight&&yo.recentChangesHighlight.dispose();const e=i.recentChanges.highlight;yo.recentChangesHighlight=L.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:L.OverviewRulerLane.Right,backgroundColor:e.locations.includes(B.Line)?new L.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(B.Overview)?new L.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(B.Gutter)?Wo.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(B.Gutter)?Wo.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if(!t&&(Go.changed(e,Go.name("blame").value)||Go.changed(e,Go.name("recentChanges").value)||Go.changed(e,Go.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===R.RecentChanges?e.reset({decoration:yo.recentChangesAnnotation,highlightDecoration:yo.recentChangesHighlight}):e.annotationType===R.Blame?e.reset({decoration:yo.blameAnnotation,highlightDecoration:yo.blameHighlight}):this.showAnnotations(e.editor,R.Heatmap))}onActiveTextEditorChanged(e){if(void 0!==e&&!X(e))return;this._editor=e;const t=this.getProvider(e);void 0===t?(q(G.AnnotationStatus,void 0),this.detachKeyboardHook()):(q(G.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=L.window.activeTextEditor;void 0!==t&&this.clear(t,bo.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,bo.DocumentChanged)}onTextDocumentClosed(e){if(Wo.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,bo.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=f.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,bo.ColumnChanged)}}async onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}async clear(e,t=bo.User){this.clearCore(se.getCorrelationKey(e),t)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await Wo.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(se.getCorrelationKey(e))}async showAnnotations(e,t,i){if(void 0===e)return!1;if(this._editor=e,!(await Wo.tracker.getOrAdd(e.document)).isBlameable)return!1;const s=this.getProvider(e);return void 0!==s&&s.annotationType===t?(await s.selection(i),!0):void 0!==await L.window.withProgress({location:L.ProgressLocation.Window},async o=>{await q(G.AnnotationStatus,ie.Computing);const a=this.showAnnotationsCore(s,e,t,i,o),r=await a;return e===this._editor&&await q(G.AnnotationStatus,r&&r.status),a})}async toggleAnnotations(e,t,i){if(void 0!==e){const i=await Wo.tracker.getOrAdd(e.document);if(t===R.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.showAnnotations(e,t,i);const o=s.annotationType!==t;return await this.clearCore(s.correlationKey,bo.User),!!o&&this.showAnnotations(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await Wo.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,bo.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(ae.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==se.getCorrelationKey(this._editor)||(await q(G.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(ae.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,s,o){if(void 0!==o){let e="annotations";switch(i){case R.Blame:e="blame annotations";break;case R.Heatmap:e="heatmap annotations";break;case R.RecentChanges:e="recent changes annotations"}o.report({message:`Computing ${e} for ${Se.basename(t.document.fileName)}`})}this.attachKeyboardHook();const a=await Wo.tracker.getOrAdd(t.document);let r=void 0;switch(i){case R.Blame:r=new vo(t,a,yo.blameAnnotation,yo.blameHighlight);break;case R.Heatmap:r=new wo(t,a,yo.blameAnnotation,void 0);break;case R.RecentChanges:r=new Co(t,a,void 0,yo.recentChangesHighlight)}if(void 0!==r&&await r.validate())return void 0!==e&&await this.clearCore(e.correlationKey,bo.User),this._annotationsDisposable||0!==this._annotationProviders.size||(ae.log("Add listener registrations for annotations"),this._annotationsDisposable=L.Disposable.from(L.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveTextEditorChanged,50),this),L.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),L.window.onDidChangeVisibleTextEditors(p.debounce(this.onVisibleTextEditorsChanged,50),this),L.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),Wo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Wo.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(r.correlationKey,r),await r.provideAnnotation(s)?(this._onDidToggleAnnotations.fire(),r):void 0}}class So extends L.CodeLens{constructor(e,t,i,s,o,a,r,n){super(a,n),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=r}getBlame(){return this.blame&&this.blame()}}class $o extends L.CodeLens{constructor(e,t,i,s,o,a,r){super(a),this.symbolKind=e,this.uri=t,this.blame=i,this.blameRange=s,this.isFullRange=o,this.desiredCommand=r}getBlame(){return this.blame()}}class Do{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new L.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let s=!1;if(e.isDirty)if(i.isDirtyIdle){const t=Go.get(Go.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.lineCount>t&&(s=!0)}else s=!0;const o=Go.get(Go.name("codeLens").value,e.uri);let a=o.scopesByLanguage&&o.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==a&&(a={language:void 0,scopes:o.scopes,symbolScopes:o.symbolScopes}),a.symbolScopes=null!=a.symbolScopes?a.symbolScopes=a.symbolScopes.map(e=>e.toLowerCase()):[];const r=[],n=i.uri;let h,c;if(s)1===a.scopes.length&&a.scopes.includes(D.Document)||(c=await L.commands.executeCommand(j.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return r;if(1===a.scopes.length&&a.scopes.includes(D.Document)?h=e.isDirty?await this._git.getBlameForFileContents(n,e.getText()):await this._git.getBlameForFile(n):[h,c]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(n,e.getText()):this._git.getBlameForFile(n),L.commands.executeCommand(j.ExecuteDocumentSymbolProvider,e.uri)]),void 0===h||0===h.lines.length)return r}if(t.isCancellationRequested)return r;const l=p.once(()=>e.validateRange(new L.Range(0,1e6,1e6,1e6))),d=s?{title:this.getDirtyTitle(o)}:void 0;if(void 0!==c&&(ae.log("GitCodeLensProvider.provideCodeLenses:",`${c.length} symbol(s) found`),c.forEach(t=>this.provideCodeLens(r,e,t,a,l,h,n,o,s,d))),(a.scopes.includes(D.Document)||a.symbolScopes.includes("file"))&&!a.symbolScopes.includes("!file")&&!r.find(e=>0===e.range.start.line&&0===e.range.end.line)){const e=l();let t=void 0;(s||o.recentChange.enabled)&&(s||(t=p.once(()=>this._git.getBlameForRangeSync(h,n,e))),r.push(new So(L.SymbolKind.File,n,t,e,!0,new L.Range(0,0,0,e.start.character),o.recentChange.command,d))),!s&&o.authors.enabled&&(void 0===t&&(t=p.once(()=>this._git.getBlameForRangeSync(h,n,e))),r.push(new $o(L.SymbolKind.File,n,t,e,!0,new L.Range(0,1,0,e.start.character),o.authors.command)))}return r}validateSymbolAndGetBlameRange(e,t,i){let s,o=!1;const a=L.SymbolKind[e.kind].toLowerCase();switch(e.kind){case L.SymbolKind.File:(t.scopes.includes(D.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`)),o&&(s=i());break;case L.SymbolKind.Package:(t.scopes.includes(D.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`)),o&&0===e.location.range.start.line&&0===e.location.range.end.line&&(s=i());break;case L.SymbolKind.Class:case L.SymbolKind.Interface:case L.SymbolKind.Module:case L.SymbolKind.Namespace:case L.SymbolKind.Struct:(t.scopes.includes(D.Containers)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`));break;case L.SymbolKind.Constructor:case L.SymbolKind.Enum:case L.SymbolKind.Function:case L.SymbolKind.Method:(t.scopes.includes(D.Blocks)||t.symbolScopes.includes(a))&&(o=!t.symbolScopes.includes(`!${a}`));break;default:t.symbolScopes.includes(a)&&(o=!t.symbolScopes.includes(`!${a}`))}return o?s||e.location.range:void 0}provideCodeLens(e,t,i,s,o,a,r,n,h,c){const l=this.validateSymbolAndGetBlameRange(i,s,o);if(void 0===l)return;const d=t.lineAt(i.location.range.start);if(e.length&&e[e.length-1].range.start.line===d.lineNumber)return;let m,u=0;if((h||n.recentChange.enabled)&&(h||(m=p.once(()=>this._git.getBlameForRangeSync(a,r,l))),e.push(new So(i.kind,r,m,l,!1,d.range.with(new L.Position(d.range.start.line,u)),n.recentChange.command,c)),u++),n.authors.enabled){let s=!l.isSingleLine;if(!s&&"csharp"===t.languageId)switch(i.kind){case L.SymbolKind.File:break;case L.SymbolKind.Package:case L.SymbolKind.Module:case L.SymbolKind.Namespace:case L.SymbolKind.Class:case L.SymbolKind.Interface:case L.SymbolKind.Constructor:case L.SymbolKind.Method:case L.SymbolKind.Function:case L.SymbolKind.Enum:s=!0}s&&!h&&(void 0===m&&(m=p.once(()=>this._git.getBlameForRangeSync(a,r,l))),e.push(new $o(i.kind,r,m,l,!1,d.range.with(new L.Position(d.range.start.line,u)),n.authors.command)))}}resolveCodeLens(e,t){return e instanceof So?this.resolveGitRecentChangeCodeLens(e,t):e instanceof $o?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=f.first(i.commits.values());let o=`${s.author}, ${s.formattedDate}`;switch(Wo.config.debug&&(o+=` [${L.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${s.shortSha})]`),e.desiredCommand){case $.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i,s);case $.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i,s);case $.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i,s);case $.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i,s);case $.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i,s);case $.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const s=i.authors.size;let o=`${s} ${s>1?"authors":"author"} (${f.first(i.authors.values()).name}${s>1?" and others":""})`;switch(Wo.config.debug&&(o+=` [${L.SymbolKind[e.symbolKind]}(${e.range.start.character}-${e.range.end.character}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${f.join(f.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case $.DiffWithPrevious:return this.applyDiffWithPreviousCommand(o,e,i);case $.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(o,e,i);case $.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(o,e,i);case $.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(o,e,i);case $.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(o,e,i);case $.ToggleFileBlame:return this.applyToggleFileBlameCommand(o,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,s){if(void 0===s){const e=i.allLines[t.range.start.line];s=i.commits.get(e.sha)}return t.command={title:e,command:Ut.DiffWithPrevious,arguments:[L.Uri.file(t.uri.fsPath),{commit:s}]},t}applyShowQuickCommitDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":$.ShowQuickCommitDetails,arguments:[L.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,s){return t.command={title:e,command:void 0!==s&&s.isUncommitted?"":$.ShowQuickCommitFileDetails,arguments:[L.Uri.file(t.uri.fsPath),{commit:s,sha:void 0===s?void 0:s.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,s){return t.command={title:e,command:$.ShowQuickCurrentBranchHistory,arguments:[L.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,s){return t.command={title:e,command:$.ShowQuickFileHistory,arguments:[L.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:Ut.ToggleFileBlame,arguments:[L.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?Go.get(Go.name("strings")("codeLens")("unsavedChanges")("recentChangeAndAuthors").value):e.recentChange.enabled?Go.get(Go.name("strings")("codeLens")("unsavedChanges")("recentChangeOnly").value):Go.get(Go.name("strings")("codeLens")("unsavedChanges")("authorsOnly").value)}}Do.selector=[{scheme:V.File},{scheme:V.Git},{scheme:V.GitLensGit}];class ko extends L.Disposable{constructor(){super(()=>this.dispose()),this._canToggle=!1,this._disposable=L.Disposable.from(Go.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(Go.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=Go.initializing(e),i=Go.name("codeLens").value;if(t||Go.changed(e,i,null)||Go.changed(e,Go.name("defaultDateStyle").value)||Go.changed(e,Go.name("defaultDateFormat").value)){t||ae.log("CodeLens config changed; resetting CodeLens provider");const e=Go.get(i);e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,q(G.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(ae.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=Go.get(Go.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.document.lineCount>t||(ae.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(ae.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new Do(Wo.context,Wo.git,Wo.tracker),this._providerDisposable=L.Disposable.from(L.languages.registerCodeLensProvider(Do.selector,this._provider),Wo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Wo.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}class Po extends L.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeActiveLine=new L.EventEmitter}get onDidChangeActiveLine(){return this._onDidChangeActiveLine.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||X(e))&&(this.reset(),this._editor=e,this._line=void 0!==e?e.selection.active.line:void 0,this.fireLineChanged({editor:e,line:this._line,reason:"editor"}))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!X(e.textEditor))return;const t=this._editor===e.textEditor?"line":"editor",i=e.selections[0].active.line;this._editor===e.textEditor&&this._line===i||(this.reset(),this._editor=e.textEditor,this._line=i,this.fireLineChanged({editor:this._editor,line:this._line,reason:t}))}get line(){return this._line}reset(){this.state=void 0}start(){void 0===this._disposable&&(this._disposable=L.Disposable.from(L.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveTextEditorChanged,0),this),L.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(L.window.activeTextEditor)))}stop(){void 0!==this._disposable&&(void 0!==this._lineChangedDebounced&&this._lineChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}fireLineChanged(e){void 0!==e.line?(void 0===this._lineChangedDebounced&&(this._lineChangedDebounced=p.debounce(e=>{L.window.activeTextEditor===e.editor&&e.line===(e.editor&&e.editor.selection.active.line)&&this._onDidChangeActiveLine.fire(e)},250,{track:!0})),this._lineChangedDebounced.pending()||this._onDidChangeActiveLine.fire(Object.assign({},e,{pending:!0})),this._lineChangedDebounced(e)):setImmediate(()=>{L.window.activeTextEditor===e.editor&&(void 0!==this._lineChangedDebounced&&this._lineChangedDebounced.cancel(),this._onDidChangeActiveLine.fire(e))})}}const Fo=L.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:L.DecorationRangeBehavior.ClosedOpen});class _o{constructor(e){this._enabled=e}get enabled(){return!this.suspended&&this._enabled}get suspended(){return void 0!==this._suspendReason}reset(e){return!(this._enabled===e&&!this.suspended)&&(this._enabled=e,this._suspendReason=void 0,!0)}resume(e){const t=void 0!==this._suspendReason;return this._suspendReason=void 0,t}suspend(e){const t=void 0===this._suspendReason;return this._suspendReason=e,t}}class Ro extends L.Disposable{constructor(){super(()=>this.dispose()),this._lineTracker=new Po,this._disposable=L.Disposable.from(this._lineTracker,Go.onDidChange(this.onConfigurationChanged,this),Wo.annotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),L.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(Go.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this.unregisterHoverProviders(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),this._lineTrackingDisposable&&this._lineTrackingDisposable.dispose(),this._statusBarItem&&this._statusBarItem.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=Go.initializing(e),i=Go.get();let s=!1;if((t||Go.changed(e,Go.name("currentLine").value))&&(s=!0,this._blameAnnotationState=void 0),(t||Go.changed(e,Go.name("hovers").value))&&(s=!0,this.unregisterHoverProviders()),t||Go.changed(e,Go.name("statusBar").value))if(s=!0,i.statusBar.enabled){const e="left"!==i.statusBar.alignment?L.StatusBarAlignment.Right:L.StatusBarAlignment.Left;void 0!==this._statusBarItem&&this._statusBarItem.alignment!==e&&(this._statusBarItem.dispose(),this._statusBarItem=void 0),this._statusBarItem=this._statusBarItem||L.window.createStatusBarItem(e,e===L.StatusBarAlignment.Right?1e3:0),this._statusBarItem.command=i.statusBar.command}else void 0!==this._statusBarItem&&(this._statusBarItem.dispose(),this._statusBarItem=void 0);if(!s)return;i.currentLine.enabled||i.statusBar.enabled||i.hovers.enabled&&i.hovers.currentLine.enabled||void 0!==this._blameAnnotationState&&this._blameAnnotationState.enabled?(this._lineTracker.start(),this._lineTrackingDisposable=this._lineTrackingDisposable||L.Disposable.from(this._lineTracker.onDidChangeActiveLine(this.onActiveLineChanged,this),Wo.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Wo.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),Wo.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))):(this._lineTracker.stop(),void 0!==this._lineTrackingDisposable&&(this._lineTrackingDisposable.dispose(),this._lineTrackingDisposable=void 0)),this.refresh(L.window.activeTextEditor,{full:!0})}onActiveLineChanged(e){e.pending||void 0===e.line?this.clear(e.editor,Wo.config.statusBar.reduceFlicker&&"line"===e.reason&&void 0!==e.line?"line":void 0):this.refresh(e.editor)}onBlameStateChanged(e){e.blameable?this.refresh(e.editor):this.clear(e.editor)}onDebugSessionStarted(){this.suspendBlameAnnotations("debugging",L.window.activeTextEditor)&&(this._debugSessionEndDisposable=L.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resumeBlameAnnotations("debugging",L.window.activeTextEditor)}onDirtyIdleTriggered(e){const t=Go.get(Go.name("advanced")("blame")("sizeThresholdAfterEdit").value);t>0&&e.document.lineCount>t||this.resumeBlameAnnotations("dirty",L.window.activeTextEditor)}async onDirtyStateChanged(e){e.dirty?this.suspendBlameAnnotations("dirty",L.window.activeTextEditor):this.resumeBlameAnnotations("dirty",L.window.activeTextEditor,{force:!0})}onFileAnnotationsToggled(){this.refresh(L.window.activeTextEditor)}async clear(e,t){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e),this._lineTracker.reset(),this.unregisterHoverProviders(),void 0!==this._statusBarItem&&"line"!==t&&this._statusBarItem.hide()}async provideDetailsHover(e,t,i){if(void 0===this._editor||this._editor.document!==e)return;if(this._lineTracker.line!==t.line)return;const s=void 0!==this._lineTracker.state?this._lineTracker.state.commit:void 0;if(void 0===s)return;const o=await Wo.annotations.getAnnotationType(this._editor);if(void 0!==o&&Wo.config.hovers.annotations.details)return;const a="line"===Wo.config.hovers.currentLine.over,r=e.validateRange(new L.Range(t.line,a?0:H,t.line,H));if(!a&&r.start.character!==t.character)return;let n=void 0!==this._lineTracker.state?this._lineTracker.state.logCommit:void 0;void 0!==n||s.isUncommitted||void 0!==(n=await Wo.git.getLogCommitForFile(s.repoPath,s.uri.fsPath,{ref:s.sha}))&&(n.previousSha=s.previousSha,n.previousFileName=s.previousFileName,void 0!==this._lineTracker.state&&(this._lineTracker.state.logCommit=n));const h=await Wo.tracker.get(e);if(void 0===h)return;const c=po.getHoverMessage(n||s,Wo.config.defaultDateFormat,h.hasRemotes,o);return new L.Hover(c,r)}async provideChangesHover(e,t,i){if(void 0===this._editor||this._editor.document!==e)return;if(this._lineTracker.line!==t.line)return;const s=void 0!==this._lineTracker.state?this._lineTracker.state.commit:void 0;if(void 0===s)return;if(Wo.config.hovers.annotations.changes){if(void 0!==await Wo.annotations.getAnnotationType(this._editor))return}const o="line"===Wo.config.hovers.currentLine.over,a=e.validateRange(new L.Range(t.line,o?0:H,t.line,H));if(!o&&a.start.character!==t.character)return;const r=await Wo.tracker.get(e);if(void 0===r)return;const n=await po.changesHover(s,t.line,r.uri);return void 0!==n.hoverMessage?new L.Hover(n.hoverMessage,a):void 0}async show(e,t,i,s){if(void 0!==i.document){if(i.document.isDirty){const e=await Wo.tracker.get(i.document);void 0!==e&&e.setForceDirtyStateChangeOnNextDocumentChange()}this.updateStatusBar(e,i),this.updateTrailingAnnotation(e,t,i,s)}}async showAnnotations(e){this.setBlameAnnotationState(!0,e)}async toggleAnnotations(e){const t=this.getBlameAnnotationState();this.setBlameAnnotationState(!t.enabled,e)}async resumeBlameAnnotations(e,t,i={}){if(!(i.force||void 0!==this._blameAnnotationState&&this._blameAnnotationState.suspended))return;let s=!1;void 0!==this._blameAnnotationState&&(s=this._blameAnnotationState.resume(e)),void 0!==t&&(i.force||s)&&await this.refresh(t)}async suspendBlameAnnotations(e,t,i={}){const s=this.getBlameAnnotationState();if(void 0===this._blameAnnotationState&&!s.enabled)return!1;void 0===this._blameAnnotationState&&(this._blameAnnotationState=new _o(s.enabled));const o=this._blameAnnotationState.suspend(e);return void 0!==t&&(i.force||o)?(await this.refresh(t),!0):void 0}async setBlameAnnotationState(e,t){let i=!0;void 0===this._blameAnnotationState?this._blameAnnotationState=new _o(e):i=this._blameAnnotationState.reset(e),void 0!==t&&i&&await this.refresh(t)}clearAnnotations(e){void 0!==e&&!0!==e._disposed&&e.setDecorations(Fo,[])}getBlameAnnotationState(){if(void 0!==this._blameAnnotationState)return this._blameAnnotationState;const e=Wo.config;return{enabled:e.currentLine.enabled||e.statusBar.enabled||e.hovers.enabled&&e.hovers.currentLine.enabled}}async refresh(e,t={}){if(void 0===e&&void 0===this._editor)return;if(void 0===e||void 0===this._lineTracker.line)return void this.clear(this._editor);this._editor!==e&&(t.full=!0,this.clearAnnotations(this._editor),this._editor=e);const i=this.getBlameAnnotationState();if(i.enabled&&(void 0===t.trackedDocument&&(t.trackedDocument=await Wo.tracker.getOrAdd(e.document)),t.trackedDocument.isBlameable))return i.enabled&&Wo.config.hovers.enabled&&Wo.config.hovers.currentLine.enabled&&(t.full||void 0===this._hoverProviderDisposable)&&this.registerHoverProviders(e,Wo.config.hovers.currentLine),void 0===this._updateBlameDebounced&&(this._updateBlameDebounced=p.debounce(this.updateBlame,50,{track:!0})),void this._updateBlameDebounced(this._lineTracker.line,e,t.trackedDocument);await this.clear(e)}registerHoverProviders(e,t){if(this.unregisterHoverProviders(),void 0===e)return;if(!t.details&&!t.changes)return;const i=[];t.changes&&i.push(L.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.details&&i.push(L.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=L.Disposable.from(...i)}unregisterHoverProviders(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}async updateBlame(e,t,i){if(this._lineTracker.reset(),this._lineTracker.line!==e||this._updateBlameDebounced&&this._updateBlameDebounced.pending())return;const s=t.document.isDirty?await Wo.git.getBlameForLineContents(i.uri,e,t.document.getText()):await Wo.git.getBlameForLine(i.uri,e);let o,a;if(this._lineTracker.line===e&&i.isBlameable&&(!this._updateBlameDebounced||!this._updateBlameDebounced.pending())){this.getBlameAnnotationState().enabled&&(a=void 0===s?void 0:s.line,o=void 0===s?void 0:s.commit)}void 0===this._lineTracker.state&&(this._lineTracker.state=new he(o)),void 0===o||void 0===a?this.clear(t):this.show(o,a,t,e)}updateStatusBar(e,t){const i=Wo.config.statusBar;if(i.enabled&&void 0!==this._statusBarItem&&X(t)){switch(this._statusBarItem.text=`$(git-commit) ${Rt.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?Wo.config.defaultDateFormat:i.dateFormat})}`,i.command){case U.ToggleFileBlame:this._statusBarItem.tooltip="Toggle Blame Annotations";break;case U.DiffWithPrevious:this._statusBarItem.command=Ut.DiffLineWithPrevious,this._statusBarItem.tooltip="Compare Line Revision with Previous";break;case U.DiffWithWorking:this._statusBarItem.command=Ut.DiffLineWithWorking,this._statusBarItem.tooltip="Compare Line Revision with Working";break;case U.ToggleCodeLens:this._statusBarItem.tooltip="Toggle Git CodeLens";break;case U.ShowQuickCommitDetails:this._statusBarItem.tooltip="Show Commit Details";break;case U.ShowQuickCommitFileDetails:this._statusBarItem.tooltip="Show Line Commit Details";break;case U.ShowQuickFileHistory:this._statusBarItem.tooltip="Show File History";break;case U.ShowQuickCurrentBranchHistory:this._statusBarItem.tooltip="Show Branch History"}this._statusBarItem.show()}}async updateTrailingAnnotation(e,t,i,s){const o=Wo.config.currentLine;if(!o.enabled||!X(i))return;s=void 0===s?t.line:s;const a=po.trailing(e,o.format,null===o.dateFormat?Wo.config.defaultDateFormat:o.dateFormat);a.range=i.document.validateRange(new L.Range(s,H,s,H)),i.setDecorations(Fo,[a])}}class To extends L.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new L.EventEmitter,this._onDidChangeTreeData=new L.EventEmitter,Wo.explorerCommands,L.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),L.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),L.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(_.Auto),this),L.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(_.List),this),L.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(_.Tree),this),L.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(Wo.config.gitExplorer.autoRefresh,!0),this),L.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(Wo.config.gitExplorer.autoRefresh,!1),this),L.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>this.setRenameFollowing(!0),this),L.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>this.setRenameFollowing(!1),this),L.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(T.History),this),L.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(T.Repository),this),Wo.context.subscriptions.push(L.window.onDidChangeActiveTextEditor(p.debounce(this.onActiveEditorChanged,500),this),L.window.onDidChangeVisibleTextEditors(p.debounce(this.onVisibleEditorsChanged,500),this),Go.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(Go.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onActiveEditorChanged(e){if(this._view!==T.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Bt.ActiveEditorChanged,t)}async onConfigurationChanged(e){const t=Go.initializing(e);if(!(t||Go.changed(e,Go.name("gitExplorer").value)||Go.changed(e,Go.name("explorers").value)||Go.changed(e,Go.name("defaultGravatarsStyle").value)||Go.changed(e,Go.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||Go.changed(e,Go.name("gitExplorer")("enabled").value))&&q(G.GitExplorer,this.config.enabled),(t||Go.changed(e,Go.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(Wo.config.gitExplorer.autoRefresh);let i=this._view;if((t||Go.changed(e,Go.name("gitExplorer")("view").value))&&((i=this.config.view)===T.Auto&&(i=Wo.context.workspaceState.get(z.GitExplorerView,T.Repository)),t))return this._view=i,q(G.GitExplorerView,this._view),this.setRoot(await this.getRootNode(L.window.activeTextEditor)),void(this._disposable=L.window.registerTreeDataProvider("gitlens.gitExplorer",this));this.reset(i,Go.changed(e,Go.name("advanced")("fileHistoryFollowsRenames").value))}onRepositoriesChanged(){this._view===T.Repository&&(this.clearRoot(),ae.log(`GitExplorer[view=${this._view}].onRepositoriesChanged`),this.refresh(Bt.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this._view===T.History&&(0!==e.length&&e.some(e=>e.document&&Wo.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Bt.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&Wo.context.workspaceState.get(z.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},Wo.config.explorers,Wo.config.gitExplorer)}get folderResourceUri(){if(void 0!==L.workspace.workspaceFolders&&0!==L.workspace.workspaceFolders.length)return L.workspace.workspaceFolders[0].uri}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?this._view===T.History?[new Mt(`No active file ${Q.Dash} no history to show`)]:[new Mt("No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async getRootNode(e){switch(this._view){case T.History:{const t=this.getHistoryNode(e||L.window.activeTextEditor);return this._loading=t.then(e=>p.wait(0)),t}default:{const e=Wo.git.getRepositories();this._loading=e.then(e=>p.wait(0));const t=[...await e];if(0===t.length)return;if(1===t.length){const e=t[0];return new ri(Te.fromRepoPath(e.path),e,this,!0)}return new pi(t,this)}}}async getHistoryNode(e){if(void 0===e||0===L.window.visibleTextEditors.length||!L.window.visibleTextEditors.some(e=>e.document&&Wo.git.isTrackable(e.document.uri)))return;if(void 0===e.document||!Wo.git.isTrackable(e.document.uri))return this._root;const t=await Te.fromUri(e.document.uri),i=await Wo.git.getRepository(t);return void 0!==i?te.equals(t,this._root&&this._root.uri)?this._root:new gi(t,i,this):void 0}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Bt.Command),ae.log(`GitExplorer[view=${this._view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this._view===T.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(L.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){ae.log(`GitExplorer[view=${this._view}].refreshNode`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){this.setView(e),t&&void 0!==this._root&&this.clearRoot(),(this.setRoot(await this.getRootNode(L.window.activeTextEditor))||t)&&this.refresh(Bt.ViewChanged)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async setFilesLayout(e){return Go.update(Go.name("gitExplorer")("files")("layout").value,e,L.ConfigurationTarget.Global)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}setView(e){this._view!==e&&(Wo.config.gitExplorer.view===T.Auto&&Wo.context.workspaceState.update(z.GitExplorerView,e),this._view=e,q(G.GitExplorerView,this._view),e!==T.Repository&&Wo.git.stopWatchingFileSystem())}async switchTo(e){this._view!==e&&this.reset(e,!0)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=Wo.context.workspaceState.get(z.GitExplorerAutoRefresh,!0):(i=t,await Wo.context.workspaceState.update(z.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=Wo.git.onDidChangeRepositories(this.onRepositoriesChanged,this),Wo.context.subscriptions.push(this._autoRefreshDisposable))),q(G.GitExplorerAutoRefresh,e&&t),i&&this.refresh(Bt.AutoRefreshChanged)}setRenameFollowing(e){Go.updateEffective(Go.name("advanced")("fileHistoryFollowsRenames").value,e)}}class Eo extends L.Disposable{constructor(){super(()=>this.dispose()),L.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),L.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),L.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),L.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),L.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),L.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),L.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),L.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),L.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),L.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),L.commands.registerCommand("gitlens.explorers.compareSelectedAncestorWithWorking",this.compareSelectedAncestorWithWorking,this),L.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),L.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),L.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),L.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),L.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),L.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),L.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),L.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),L.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),L.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),L.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),L.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),L.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),L.commands.registerCommand("gitlens.explorers.terminalPushCommit",this.terminalPushCommit,this),L.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),L.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),L.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),L.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),L.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),L.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){return await Wo.git.checkoutFile(e.uri),this.openFile(e)}compareWithHead(e){e instanceof It&&Wo.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&Wo.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof It&&Wo.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareSelectedAncestorWithWorking(e){if(void 0===this._selection||!(e instanceof Kt))return;if(this._selection.repoPath!==e.repoPath||"branch"!==this._selection.type)return;const t=await Wo.git.getMergeBase(this._selection.repoPath,this._selection.ref,e.ref);void 0!==t&&Wo.resultsExplorer.showComparisonInResults(this._selection.repoPath,t,"")}compareWithSelected(e){void 0!==this._selection&&e instanceof It&&this._selection.repoPath===e.repoPath&&Wo.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref)}selectForCompare(e){if(!(e instanceof It))return;const t=e instanceof Kt?"branch":"ref";this._selection={ref:e.ref,repoPath:e.repoPath,type:t},q(G.ExplorersCanCompare,t)}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,s]=t.arguments;return s.showOptions.preview=!1,L.commands.executeCommand(t.command,i,s)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return L.commands.executeCommand(Ut.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return Pi(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return Pi(t.uri||("D"===e.commit.status?Te.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):Te.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>Te.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:Lt.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?Te.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=o.filterMap(e.commit.fileStatuses,e=>Te.fromFileStatus(e,i));for(const e of s)await Pi(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=o.filterMap(e.commit.fileStatuses,t=>Te.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await Pi(e,t)}async openDiffWith(e,t,i,s={preserveFocus:!1,preview:!1}){const o={repoPath:e,lhs:t,rhs:i,showOptions:s};return L.commands.executeCommand(Ut.DiffWith,o)}async openFileRevisionInRemote(e){return L.commands.executeCommand(Ut.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){if(!(e instanceof Kt))return;const t=`checkout ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof It))return;let t=!1,i=void 0;e instanceof Kt&&e.branch.remote&&(t=!0,i=e.branch.getName());const s=await L.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});if(void 0===s||""===s)return;const o=`branch ${t?"-t ":""}${s} ${e.ref}`;this.sendTerminalCommand(o,e.repoPath)}terminalDeleteBranch(e){if(!(e instanceof Kt))return;const t=e.branch.remote?`push ${e.branch.remote} :${e.ref}`:`branch -d ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalMergeBranch(e){if(!(e instanceof Kt))return;const t=`merge ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRebaseBranch(e){if(!(e instanceof Kt))return;const t=`rebase -i ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof Kt){if(!e.branch.current||!e.branch.tracking)return;const t=`rebase -i ${e.branch.tracking}`;this.sendTerminalCommand(t,e.repoPath)}else if(e instanceof Zt){const t=`rebase -i ${e.status.upstream}`;this.sendTerminalCommand(t,e.status.repoPath)}}terminalSquashBranchIntoCommit(e){if(!(e instanceof Kt))return;const t=`merge --squash ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalCherryPickCommit(e){if(!(e instanceof Qt))return;const t=`cherry-pick -e ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}async terminalPushCommit(e){if(!(e instanceof Qt))return;const t=e.branch||await Wo.git.getBranch(e.repoPath);if(void 0===t)return;const i=`push ${t.getRemote()} ${e.ref}:${t.getName()}`;this.sendTerminalCommand(i,e.repoPath)}terminalRebaseCommit(e){if(!(e instanceof Qt))return;const t=`rebase -i ${e.ref}^`;this.sendTerminalCommand(t,e.repoPath)}terminalResetCommit(e){if(!(e instanceof Qt))return;const t=`reset --soft ${e.ref}^`;this.sendTerminalCommand(t,e.repoPath)}terminalRevertCommit(e){if(!(e instanceof Qt))return;const t=`revert -e ${e.ref}`;this.sendTerminalCommand(t,e.repoPath)}terminalRemoveRemote(e){if(!(e instanceof qt))return;const t=`remote remove ${e.remote.name}`;this.sendTerminalCommand(t,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof It))return;const t=await L.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await L.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const s=`tag ${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand(s,e.repoPath)}terminalDeleteTag(e){e instanceof oi&&this.sendTerminalCommand(`tag -d ${e.ref}`,e.repoPath)}ensureTerminal(){return void 0===this._terminal&&(this._terminal=L.window.createTerminal(M),this._disposable=L.window.onDidCloseTerminal(e=>{e.name===M&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),Wo.context.subscriptions.push(this._disposable)),this._terminal}sendTerminalCommand(e,t){const i=this.ensureTerminal();i.show(!1),i.sendText(`git -C ${t} ${e}`,!1)}}class Bo{async provideTextDocumentContent(e,t){const i=Te.fromRevisionUri(e);if(!i.repoPath||i.sha===Lt.deletedSha)return"";try{return await Wo.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return ae.error(e,"GitContentProvider","getVersionedFileText"),void L.window.showErrorMessage(`Unable to show Git revision ${Lt.shortenSha(i.sha)} of '${Se.relative(i.repoPath,i.fsPath)}'`)}}}Bo.scheme=V.GitLensGit;class No extends L.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Ao extends L.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Uo{async provideCodeLenses(e,t){const i=Te.fromRevisionUri(e.uri),s=[],o=await Wo.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===o?s:(o.previousSha&&s.push(new Ao(o.previousUri.fsPath,o,new L.Range(0,0,0,1))),s.push(new No(o.uri.fsPath,o,new L.Range(0,1,0,2))),s)}resolveCodeLens(e,t){return e instanceof No?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof Ao?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:Ut.DiffWithWorking,arguments:[L.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:Ut.DiffWithPrevious,arguments:[L.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}Uo.selector={scheme:V.GitLensGit};const Lo=L.Uri.parse("gitlens://authority/settings"),Oo=L.Uri.parse("gitlens://authority/welcome");class Io extends L.Disposable{constructor(){super(()=>this.dispose()),this._onDidChange=new L.EventEmitter,this._scope=new Map,this._disposable=L.Disposable.from(L.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),L.workspace.registerTextDocumentContentProvider(Lo.scheme,this),L.commands.registerCommand("gitlens.showSettingsPage",this.showSettings,this),L.commands.registerCommand("gitlens.showWelcomePage",this.showWelcome,this),L.commands.registerCommand("gitlens.saveSettings",this.save,this))}get onDidChange(){return this._onDidChange.event}dispose(){this._disposable.dispose()}onTextDocumentClosed(e){this._scope.delete(e.uri.toString())}async provideTextDocumentContent(e){let t=(await L.workspace.openTextDocument(L.Uri.file(Wo.context.asAbsolutePath(`${e.path}.html`)))).getText().replace(/{{root}}/g,L.Uri.file(Wo.context.asAbsolutePath(".")).toString());return t.includes("'{{data}}'")&&(t=t.replace(/'{{data}}'/g,JSON.stringify({config:Wo.config,scope:this.getScope(e),scopes:this.getAvailableScopes(),uri:e.toString()}))),t}getAvailableScopes(){const e=[["user","User Settings"]];return void 0!==L.workspace.workspaceFolders&&L.workspace.workspaceFolders.length&&e.push(["workspace","Workspace Settings"]),e}getScope(e){return this._scope.get(e.toString())||"user"}refresh(e){ae.log("PageProvider.refresh"),this._onDidChange.fire(e||Lo)}async save(e){ae.log(`PageProvider.save: options=${JSON.stringify(e)}`),this._scope.set(e.uri,e.scope);const t="workspace"===e.scope?L.ConfigurationTarget.Workspace:L.ConfigurationTarget.Global;for(const i in e.changes){(await Go.inspect(i)).defaultValue===e.changes[i]?await Go.update(i,void 0,t):await Go.update(i,e.changes[i],t)}}async showSettings(){return await L.commands.executeCommand("vscode.previewHtml",Lo,L.ViewColumn.Active,"GitLens Settings")}async showWelcome(){return await L.commands.executeCommand("vscode.previewHtml",Oo,L.ViewColumn.Active,"Welcome to GitLens")}}class Mo extends L.Disposable{constructor(){super(()=>this.dispose()),this._roots=[],this._onDidChangeTreeData=new L.EventEmitter,Wo.explorerCommands,L.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),L.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),L.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(_.Auto),this),L.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(_.List),this),L.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(_.Tree),this),L.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),L.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),L.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),L.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),L.commands.registerCommand("gitlens.resultsExplorer.swapComparision",this.swapComparision,this),q(G.ResultsExplorerKeepResults,this.keepResults),Wo.context.subscriptions.push(Go.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(Go.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=Go.initializing(e);(t||Go.changed(e,Go.name("resultsExplorer").value)||Go.changed(e,Go.name("explorers").value)||Go.changed(e,Go.name("defaultGravatarsStyle").value))&&(t||0===this._roots.length||this.refresh(Bt.ConfigurationChanged),t&&(this._disposable=L.window.registerTreeDataProvider("gitlens.resultsExplorer",this)))}get config(){return Object.assign({},Wo.config.explorers,Wo.config.resultsExplorer)}get folderResourceUri(){if(void 0!==L.workspace.workspaceFolders&&0!==L.workspace.workspaceFolders.length)return L.workspace.workspaceFolders[0].uri}get keepResults(){return Wo.context.workspaceState.get(z.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),q(G.ResultsExplorer,!1)}async getChildren(e){return 0===this._roots.length?[new Mt("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=Bt.Command),ae.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){ae.log("ResultsExplorer.refreshNode"),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){ae.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}showComparisonInResults(e,t,i){this.addResults(new mi(e,t,i,this)),this.showResults()}showCommitInResults(e){this.addResults(new hi(e,this)),this.showResults()}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.addResults(new ci(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,a=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let r="";if(await Wo.git.getRepositoryCount()>1){const t=await Wo.git.getRepository(e.repoPath);r=` ${y.pad(Q.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return 1===s?`1 ${a.singular} for ${t.label}${r}`:`${0===s?"No":`${s}${o?"+":""}`} ${a.plural} for ${t.label}${r}`},p.seeded(i,e),this,Nt.SearchResults)),this.showResults()}async showResults(){await L.commands.executeCommand("workbench.view.explorer"),Ti.showResultExplorerInfoMessage(),q(G.ResultsExplorer,!0)}addResults(e){return!this._roots.includes(e)&&(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),!0)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}async setFilesLayout(e){return Go.update(Go.name("resultsExplorer")("files")("layout").value,e,L.ConfigurationTarget.Global)}setKeepResults(e){Wo.context.workspaceState.update(z.ResultsExplorerKeepResults,e),q(G.ResultsExplorerKeepResults,e)}swapComparision(e){e instanceof mi&&this.showComparisonInResults(e.repoPath,e.ref2,e.ref1)}}class Wo{static initialize(e,t){if(this._context=e,this._config=t,e.subscriptions.push(this._tracker=new ce),e.subscriptions.push(this._git=new Lt),this._tracker.initialize(),e.subscriptions.push(this._annotationController=new xo),e.subscriptions.push(this._currentLineController=new Ro),e.subscriptions.push(this._codeLensController=new ko),e.subscriptions.push(this._keyboard=new Ii),e.subscriptions.push(this._pageProvider=new Io),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new To);else{let t;t=Go.onDidChange(i=>{Go.changed(i,Go.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new To))})}e.subscriptions.push(L.workspace.registerTextDocumentContentProvider(Bo.scheme,new Bo)),e.subscriptions.push(L.languages.registerCodeLensProvider(Uo.selector,new Uo))}static get annotations(){return this._annotationController}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=Go.get()),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new Eo),this._explorerCommands}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._currentLineController}static get pages(){return this._pageProvider}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new Mo),this._resultsExplorer}static get tracker(){return this._tracker}static resetConfig(){this._config=void 0}}const Ho=new Proxy({},{get:(e,t,i)=>Ho});class jo{constructor(){this._onDidChange=new L.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1}}static configure(e){e.subscriptions.push(L.workspace.onDidChangeConfiguration(Go.onConfigurationChanged,Go))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(O,null))return;Wo.resetConfig(),void 0!==Wo.pages&&Wo.pages.refresh(),Go.changed(e,Go.name("defaultGravatarsStyle").value)&&Ee.clear();const t=Go.name("keymap").value;Go.changed(e,t)&&q(G.KeyMap,this.get(t)),this._onDidChange.fire(e)}get(e,t,i){return void 0===i?L.workspace.getConfiguration(void 0===e?void 0:O,t).get(void 0===e?O:e):L.workspace.getConfiguration(void 0===e?void 0:O,t).get(void 0===e?O:e,i)}changed(e,t,i){return e.affectsConfiguration(`${O}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return L.workspace.getConfiguration(void 0===e?void 0:O,t).inspect(void 0===e?O:e)}async migrate(e,t,i){const s=Go.inspect(e);void 0!==s&&(void 0!==s.globalValue&&await this.update(t,i?i(s.globalValue):s.globalValue,L.ConfigurationTarget.Global),void 0!==s.workspaceValue&&await this.update(t,i?i(s.workspaceValue):s.workspaceValue,L.ConfigurationTarget.Workspace),void 0!==s.workspaceFolderValue&&await this.update(t,i?i(s.workspaceFolderValue):s.workspaceFolderValue,L.ConfigurationTarget.WorkspaceFolder))}async migrateIfMissing(e,t,i){const s=Go.inspect(e);if(void 0===s)return;const o=Go.inspect(t);void 0!==s.globalValue&&(void 0!==o&&void 0!==o.globalValue||await this.update(t,i?i(s.globalValue):s.globalValue,L.ConfigurationTarget.Global)),void 0!==s.workspaceValue&&(void 0!==o&&void 0!==o.workspaceValue||await this.update(t,i?i(s.workspaceValue):s.workspaceValue,L.ConfigurationTarget.Workspace)),void 0!==s.workspaceFolderValue&&(void 0!==o&&void 0!==o.workspaceFolderValue||await this.update(t,i?i(s.workspaceFolderValue):s.workspaceFolderValue,L.ConfigurationTarget.WorkspaceFolder))}name(e){return p.propOf(Ho,e)}update(e,t,i,s){return L.workspace.getConfiguration(O,i===L.ConfigurationTarget.Global?void 0:s).update(e,t,i)}async updateEffective(e,t,i=null){const s=await Go.inspect(e,i);void 0!==s.workspaceFolderValue?await Go.update(e,t,L.ConfigurationTarget.WorkspaceFolder,i):void 0!==s.workspaceValue?await Go.update(e,t,L.ConfigurationTarget.Workspace):await Go.update(e,t,L.ConfigurationTarget.Global)}}const Go=new jo;t.activate=async function(e){const t=process.hrtime();ae.configure(e);const i=L.extensions.getExtension(W).packageJSON.version,o=L.workspace.getConfiguration("git",null).get("enabled",!0);if(!o)return ae.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),void q(G.Enabled,o);jo.configure(e);const a=e.globalState.get(K.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=x.fromString(t);try{if(1!==x.compare(i,x.from(6,1,2)))try{const t=Go.name("advanced")("messages").value,i=Go.get(t);let o=!1;for(const t of s.values(Ri)){const s=e.globalState.get(t);void 0!==s&&(o=!0,i[t]=s,e.globalState.update(t,void 0))}if(!o)return;await Go.update(t,i,L.ConfigurationTarget.Global)}catch(e){ae.error(e,"migrateSettings - messages")}if(1!==x.compare(i,x.from(7,1,0))){const e=Go.name("advanced")("quickPick")("closeOnFocusOut").value;await Go.migrate(e,e,e=>!e)}if(1!==x.compare(i,x.from(7,3,0,"beta2"))&&await Go.migrate("advanced.maxQuickHistory",Go.name("advanced")("maxListItems").value),1!==x.compare(i,x.from(7,3,0,"beta4"))&&await Go.migrate("gitExplorer.gravatarsDefault",Go.name("defaultGravatarsStyle").value),1!==x.compare(i,x.from(7,5,10))&&(await Go.migrate("annotations.file.gutter.gravatars",Go.name("blame")("avatars").value),await Go.migrate("annotations.file.gutter.compact",Go.name("blame")("compact").value),await Go.migrate("annotations.file.gutter.dateFormat",Go.name("blame")("dateFormat").value),await Go.migrate("annotations.file.gutter.format",Go.name("blame")("format").value),await Go.migrate("annotations.file.gutter.heatmap.enabled",Go.name("blame")("heatmap")("enabled").value),await Go.migrate("annotations.file.gutter.heatmap.location",Go.name("blame")("heatmap")("location").value),await Go.migrate("annotations.file.gutter.lineHighlight.enabled",Go.name("blame")("highlight")("enabled").value),await Go.migrate("annotations.file.gutter.lineHighlight.locations",Go.name("blame")("highlight")("locations").value),await Go.migrate("annotations.file.gutter.separateLines",Go.name("blame")("separateLines").value),await Go.migrate("codeLens.locations",Go.name("codeLens")("scopes").value),await Go.migrate("codeLens.perLanguageLocations",Go.name("codeLens")("scopesByLanguage").value,e=>{const t=e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}));return t}),await Go.migrate("codeLens.customLocationSymbols",Go.name("codeLens")("symbolScopes").value),await Go.migrate("annotations.line.trailing.dateFormat",Go.name("currentLine")("dateFormat").value),await Go.migrate("blame.line.enabled",Go.name("currentLine")("enabled").value),await Go.migrate("annotations.line.trailing.format",Go.name("currentLine")("format").value),await Go.migrate("annotations.file.gutter.hover.changes",Go.name("hovers")("annotations")("changes").value),await Go.migrate("annotations.file.gutter.hover.details",Go.name("hovers")("annotations")("details").value),await Go.migrate("annotations.file.gutter.hover.details",Go.name("hovers")("annotations")("enabled").value),await Go.migrate("annotations.file.gutter.hover.wholeLine",Go.name("hovers")("annotations")("over").value,e=>e?"line":"annotation"),await Go.migrate("annotations.line.trailing.hover.changes",Go.name("hovers")("currentLine")("changes").value),await Go.migrate("annotations.line.trailing.hover.details",Go.name("hovers")("currentLine")("details").value),await Go.migrate("blame.line.enabled",Go.name("hovers")("currentLine")("enabled").value),await Go.migrate("annotations.line.trailing.hover.wholeLine",Go.name("hovers")("currentLine")("over").value,e=>e?"line":"annotation"),await Go.migrate("gitExplorer.gravatars",Go.name("explorers")("avatars").value),await Go.migrate("gitExplorer.commitFileFormat",Go.name("explorers")("commitFileFormat").value),await Go.migrate("gitExplorer.commitFormat",Go.name("explorers")("commitFormat").value),await Go.migrate("gitExplorer.stashFileFormat",Go.name("explorers")("stashFileFormat").value),await Go.migrate("gitExplorer.stashFormat",Go.name("explorers")("stashFormat").value),await Go.migrate("gitExplorer.statusFileFormat",Go.name("explorers")("statusFileFormat").value),await Go.migrate("recentChanges.file.lineHighlight.locations",Go.name("recentChanges")("highlight")("locations").value)),1!==x.compare(i,x.from(8,0,0,"beta2"))&&(await Go.migrate("debug",Go.name("outputLevel").value,e=>e?A.Debug:Go.get(Go.name("outputLevel").value)),await Go.migrate("debug",Go.name("debug").value,e=>void 0)),1!==x.compare(i,x.from(8,0,0,"rc"))){let e=Go.name("blame")("highlight")("locations").value;await Go.migrate(e,e,e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}),e=Go.name("recentChanges")("highlight")("locations").value,await Go.migrate(e,e,e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e})}1!==x.compare(i,x.from(8,0,0))&&(await Go.migrateIfMissing("annotations.file.gutter.gravatars",Go.name("blame")("avatars").value),await Go.migrateIfMissing("annotations.file.gutter.compact",Go.name("blame")("compact").value),await Go.migrateIfMissing("annotations.file.gutter.dateFormat",Go.name("blame")("dateFormat").value),await Go.migrateIfMissing("annotations.file.gutter.format",Go.name("blame")("format").value),await Go.migrateIfMissing("annotations.file.gutter.heatmap.enabled",Go.name("blame")("heatmap")("enabled").value),await Go.migrateIfMissing("annotations.file.gutter.heatmap.location",Go.name("blame")("heatmap")("location").value),await Go.migrateIfMissing("annotations.file.gutter.lineHighlight.enabled",Go.name("blame")("highlight")("enabled").value),await Go.migrateIfMissing("annotations.file.gutter.lineHighlight.locations",Go.name("blame")("highlight")("locations").value),await Go.migrateIfMissing("annotations.file.gutter.separateLines",Go.name("blame")("separateLines").value),await Go.migrateIfMissing("codeLens.locations",Go.name("codeLens")("scopes").value),await Go.migrateIfMissing("codeLens.perLanguageLocations",Go.name("codeLens")("scopesByLanguage").value,e=>{const t=e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}));return t}),await Go.migrateIfMissing("codeLens.customLocationSymbols",Go.name("codeLens")("symbolScopes").value),await Go.migrateIfMissing("annotations.line.trailing.dateFormat",Go.name("currentLine")("dateFormat").value),await Go.migrateIfMissing("blame.line.enabled",Go.name("currentLine")("enabled").value),await Go.migrateIfMissing("annotations.line.trailing.format",Go.name("currentLine")("format").value),await Go.migrateIfMissing("annotations.file.gutter.hover.changes",Go.name("hovers")("annotations")("changes").value),await Go.migrateIfMissing("annotations.file.gutter.hover.details",Go.name("hovers")("annotations")("details").value),await Go.migrateIfMissing("annotations.file.gutter.hover.details",Go.name("hovers")("annotations")("enabled").value),await Go.migrateIfMissing("annotations.file.gutter.hover.wholeLine",Go.name("hovers")("annotations")("over").value,e=>e?"line":"annotation"),await Go.migrateIfMissing("annotations.line.trailing.hover.changes",Go.name("hovers")("currentLine")("changes").value),await Go.migrateIfMissing("annotations.line.trailing.hover.details",Go.name("hovers")("currentLine")("details").value),await Go.migrateIfMissing("blame.line.enabled",Go.name("hovers")("currentLine")("enabled").value),await Go.migrateIfMissing("annotations.line.trailing.hover.wholeLine",Go.name("hovers")("currentLine")("over").value,e=>e?"line":"annotation"),await Go.migrateIfMissing("gitExplorer.gravatars",Go.name("explorers")("avatars").value),await Go.migrateIfMissing("gitExplorer.commitFileFormat",Go.name("explorers")("commitFileFormat").value),await Go.migrateIfMissing("gitExplorer.commitFormat",Go.name("explorers")("commitFormat").value),await Go.migrateIfMissing("gitExplorer.stashFileFormat",Go.name("explorers")("stashFileFormat").value),await Go.migrateIfMissing("gitExplorer.stashFormat",Go.name("explorers")("stashFormat").value),await Go.migrateIfMissing("gitExplorer.statusFileFormat",Go.name("explorers")("statusFileFormat").value),await Go.migrateIfMissing("recentChanges.file.lineHighlight.locations",Go.name("recentChanges")("highlight")("locations").value))}catch(e){ae.error(e,"migrateSettings")}}(e,a);const r=Go.get();try{await Lt.initialize(r.advanced.git||L.workspace.getConfiguration("git").get("path"))}catch(e){return ae.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await L.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${O}.${Go.name("advanced")("git").value}' is pointed to its installed location.`),void q(G.Enabled,!1)}Wo.initialize(e,r),q(G.KeyMap,Wo.config.keymap),Wo.context.subscriptions.push(new Ei),Wo.context.subscriptions.push(new Us),Wo.context.subscriptions.push(new As),Wo.context.subscriptions.push(new Bi),Wo.context.subscriptions.push(new Ni),Wo.context.subscriptions.push(new xs),Wo.context.subscriptions.push(new Ss),Wo.context.subscriptions.push(new $s),Wo.context.subscriptions.push(new Ds),Wo.context.subscriptions.push(new ks),Wo.context.subscriptions.push(new Ps),Wo.context.subscriptions.push(new Fs),Wo.context.subscriptions.push(new _s),Wo.context.subscriptions.push(new Rs),Wo.context.subscriptions.push(new Ts),Wo.context.subscriptions.push(new Ls),Wo.context.subscriptions.push(new Os),Wo.context.subscriptions.push(new Is),Wo.context.subscriptions.push(new Ms),Wo.context.subscriptions.push(new Ws),Wo.context.subscriptions.push(new Hs),Wo.context.subscriptions.push(new js),Wo.context.subscriptions.push(new Gs),Wo.context.subscriptions.push(new Fi),Wo.context.subscriptions.push(new qs),Wo.context.subscriptions.push(new Xs),Wo.context.subscriptions.push(new co),Wo.context.subscriptions.push(new lo),Wo.context.subscriptions.push(new mo),Wo.context.subscriptions.push(new uo),Wo.context.subscriptions.push(new Vs),Wo.context.subscriptions.push(new Ys),Wo.context.subscriptions.push(new Js),Wo.context.subscriptions.push(new to),Wo.context.subscriptions.push(new Zs),Wo.context.subscriptions.push(new eo),Wo.context.subscriptions.push(new zs),Wo.context.subscriptions.push(new io),Wo.context.subscriptions.push(new so),Wo.context.subscriptions.push(new oo),Wo.context.subscriptions.push(new ao),Wo.context.subscriptions.push(new ro),Wo.context.subscriptions.push(new no),Wo.context.subscriptions.push(new ho),function(e){if(Lt.validateGitVersion(2,2))return;Ti.showUnsupportedGitVersionErrorMessage(e)}(Lt.getGitVersion()),async function(e,t){if(void 0===t)return ae.log("GitLens first-time install"),void(Wo.config.showWhatsNewAfterUpgrades&&await L.commands.executeCommand(Ut.ShowWelcomePage));if(t!==e&&(ae.log(`GitLens upgraded from v${t} to v${e}`),0===x.compare(x.fromString(t),x.from(8,0,0))))return void await L.commands.executeCommand(Ut.ShowWelcomePage);if(!Wo.config.showWhatsNewAfterUpgrades)return;const[i,s]=e.split("."),[o,a]=t.split(".");if(i===o&&s===a)return;if(i<o||i===o&&s<a)return;await L.commands.executeCommand(Ut.ShowWelcomePage)}(i,a),e.globalState.update(K.GitLensVersion,i);const n=process.hrtime(t);ae.log(`GitLens(v${i}) activated in ${1e3*n[0]+Math.floor(n[1]/1e6)} ms`)},t.deactivate=function(){}},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("lodash.once")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("tmp")},function(e,t){e.exports=require("copy-paste")}]);